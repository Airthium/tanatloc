{"ast":null,"code":"import _Space from \"antd/lib/space\";\nimport _Typography from \"antd/lib/typography\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport _Modal from \"antd/lib/modal\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport _Layout from \"antd/lib/layout\";\nimport _Menu from \"antd/lib/menu\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/** @module renderer/components/project/simulation */\nimport { useState, useEffect } from 'react';\nimport { WarningOutlined } from '@ant-design/icons';\nimport { addedDiff, updatedDiff } from 'deep-object-diff';\nimport merge from 'lodash.merge';\nimport { Error } from '../../assets/notification';\nimport Panel from '../panel';\nimport About from './about';\nimport Geometry from './geometry';\nimport Materials from './materials';\nimport Parameters from './parameters';\nimport BoundaryConditions from './boundaryConditions';\nimport Run from './run';\nimport SimulationAPI from '../../../../src/api/simulation';\nimport models from '../../../../models';\n/**\n * Errors\n */\n\nconst errors = {\n  updateError: 'Unable to update the simulation'\n};\n/**\n * Simulation Selector\n * @param {Object} props Props\n */\n\nconst Selector = ({\n  visible,\n  onOk,\n  onCancel\n}) => {\n  // State\n  const {\n    0: current,\n    1: setCurrent\n  } = useState();\n  const {\n    0: loading,\n    1: setLoading\n  } = useState(false);\n  /**\n   * On select\n   * @param {Object} data Data { key }\n   */\n\n  const onSelect = ({\n    key\n  }) => {\n    const model = models.find(m => m.algorithm === key);\n    setCurrent(_objectSpread({}, model)); // TODO review that\n  };\n  /**\n   * On create\n   */\n\n\n  const onCreate = async () => {\n    setLoading(true);\n    if (current) onOk(current);\n    setLoading(false);\n  };\n  /**\n   * MatJax\n   */\n\n\n  useEffect(() => {\n    var _window$MathJax;\n\n    (_window$MathJax = window.MathJax) === null || _window$MathJax === void 0 ? void 0 : _window$MathJax.typeset();\n  }, [current]);\n  /**\n   * Render\n   */\n\n  return /*#__PURE__*/_jsx(_Modal, {\n    visible: visible,\n    title: \"Create simulation\",\n    okText: \"Create\",\n    okButtonProps: {\n      loading: loading\n    },\n    onOk: onCreate,\n    onCancel: onCancel,\n    children: /*#__PURE__*/_jsxs(_Layout, {\n      children: [/*#__PURE__*/_jsx(_Layout.Sider, {\n        theme: \"light\",\n        children: /*#__PURE__*/_jsx(_Menu, {\n          mode: \"inline\",\n          onSelect: onSelect,\n          children: models.map(model => {\n            return /*#__PURE__*/_jsx(_Menu.Item, {\n              children: model.name\n            }, model.algorithm);\n          })\n        })\n      }), /*#__PURE__*/_jsx(_Layout.Content, {\n        children: /*#__PURE__*/_jsx(\"div\", {\n          dangerouslySetInnerHTML: {\n            __html: current === null || current === void 0 ? void 0 : current.description\n          }\n        })\n      })]\n    })\n  });\n};\n/**\n * Simulation\n * @param {Object} props Props\n */\n\n\nconst Simulation = ({\n  project,\n  simulation,\n  type,\n  part,\n  onClose\n}) => {\n  // State\n  const {\n    0: needUpdate,\n    1: setNeedUpdate\n  } = useState(false);\n  const {\n    0: loading,\n    1: setLoading\n  } = useState(false);\n  const {\n    0: visible,\n    1: setVisible\n  } = useState(false);\n  const {\n    0: title,\n    1: setTitle\n  } = useState(); // Data\n\n  const [, {\n    mutateOneSimulation\n  }] = SimulationAPI.useSimulations(project === null || project === void 0 ? void 0 : project.simulations); // Check model update\n\n  useEffect(() => {\n    const currentModel = models.find(m => {\n      var _simulation$scheme;\n\n      return m.algorithm === (simulation === null || simulation === void 0 ? void 0 : (_simulation$scheme = simulation.scheme) === null || _simulation$scheme === void 0 ? void 0 : _simulation$scheme.algorithm);\n    });\n\n    if (currentModel && simulation !== null && simulation !== void 0 && simulation.scheme) {\n      const added = addedDiff(simulation.scheme, currentModel);\n      const updated = updatedDiff(simulation.scheme, currentModel);\n      if (Object.keys(added).length || Object.keys(updated).length) setNeedUpdate(true);else setNeedUpdate(false);\n    }\n  }, [simulation]);\n  /**\n   * Simulation effect\n   */\n\n  useEffect(() => {\n    var _simulation$scheme2, _configuration$geomet;\n\n    setVisible(simulation);\n    const configuration = simulation === null || simulation === void 0 ? void 0 : (_simulation$scheme2 = simulation.scheme) === null || _simulation$scheme2 === void 0 ? void 0 : _simulation$scheme2.configuration; // Check if a part is visible\n\n    if (configuration && !configuration.part && (_configuration$geomet = configuration.geometry) !== null && _configuration$geomet !== void 0 && _configuration$geomet.file) {\n      const newSimulation = _objectSpread({}, simulation); // Update local\n\n\n      newSimulation.scheme.configuration.part = configuration.geometry.file; // Update simulation\n\n      SimulationAPI.update({\n        id: simulation.id\n      }, [{\n        key: 'scheme',\n        type: 'json',\n        method: 'diff',\n        path: ['configuration', 'part'],\n        value: configuration.geometry.file\n      }]).then(() => {\n        // Mutate\n        mutateOneSimulation(newSimulation);\n      }).catch(err => {\n        Error(errors.updateError, err);\n      });\n    }\n\n    const subScheme = configuration === null || configuration === void 0 ? void 0 : configuration[type];\n    setTitle(subScheme ? subScheme.title : 'About');\n  }, [simulation, type]);\n  /**\n   * On update\n   */\n\n  const onUpdate = async () => {\n    setLoading(true);\n\n    try {\n      // Current model\n      const currentModel = models.find(m => {\n        var _simulation$scheme3;\n\n        return m.algorithm === (simulation === null || simulation === void 0 ? void 0 : (_simulation$scheme3 = simulation.scheme) === null || _simulation$scheme3 === void 0 ? void 0 : _simulation$scheme3.algorithm);\n      }); // New simulation\n\n      const newSimulation = _objectSpread({}, simulation); // Merge\n\n\n      merge(newSimulation.scheme, currentModel); // Update simulation\n\n      await SimulationAPI.update({\n        id: simulation.id\n      }, [{\n        key: 'scheme',\n        value: newSimulation.scheme\n      }]); // Mutate\n\n      mutateOneSimulation(newSimulation);\n    } catch (err) {\n      Error(errors.updateError, err);\n    }\n\n    setLoading(false);\n    setNeedUpdate(false);\n  };\n  /**\n   * Render\n   */\n\n\n  return /*#__PURE__*/_jsxs(_Fragment, {\n    children: [/*#__PURE__*/_jsx(_Modal, {\n      title: /*#__PURE__*/_jsxs(_Fragment, {\n        children: [/*#__PURE__*/_jsx(WarningOutlined, {\n          style: {\n            color: 'orange',\n            marginRight: '5px'\n          }\n        }), \"Update\"]\n      }),\n      visible: needUpdate,\n      onOk: onUpdate,\n      okText: \"Yes\",\n      confirmLoading: loading,\n      onCancel: () => setNeedUpdate(false),\n      cancelText: \"No\",\n      children: /*#__PURE__*/_jsxs(_Space, {\n        direction: \"vertical\",\n        children: [/*#__PURE__*/_jsx(_Typography.Text, {\n          children: \"Your model needs an update!\"\n        }), /*#__PURE__*/_jsx(_Typography.Text, {\n          strong: true,\n          children: \"Update now?\"\n        })]\n      })\n    }), /*#__PURE__*/_jsxs(Panel, {\n      visible: visible,\n      title: title,\n      onClose: onClose,\n      children: [type === 'about' && /*#__PURE__*/_jsx(About, {\n        project: project,\n        simulation: simulation\n      }), type === 'geometry' && /*#__PURE__*/_jsx(Geometry, {\n        project: project,\n        simulation: simulation,\n        part: part\n      }), type === 'parameters' && /*#__PURE__*/_jsx(Parameters, {\n        project: project,\n        simulation: simulation\n      }), type === 'materials' && /*#__PURE__*/_jsx(Materials, {\n        project: project,\n        simulation: simulation,\n        part: part,\n        setVisible: setVisible\n      }), type === 'boundaryConditions' && /*#__PURE__*/_jsx(BoundaryConditions, {\n        project: project,\n        simulation: simulation,\n        part: part,\n        setVisible: setVisible\n      }), type === 'run' && /*#__PURE__*/_jsx(Run, {\n        project: project,\n        simulation: simulation\n      })]\n    })]\n  });\n};\n\nSimulation.Selector = Selector;\nexport default Simulation;","map":null,"metadata":{},"sourceType":"module"}