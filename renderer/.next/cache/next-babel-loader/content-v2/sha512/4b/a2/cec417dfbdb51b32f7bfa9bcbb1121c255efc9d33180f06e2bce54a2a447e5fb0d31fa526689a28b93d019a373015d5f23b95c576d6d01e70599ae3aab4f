{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\n\n/** @module renderer/components/background */\nimport { useRef, useEffect } from 'react';\nimport { Mesh, MeshBasicMaterial, PerspectiveCamera, Scene, TetrahedronGeometry, Vector3, WebGLRenderer } from 'three/build/three.module';\n/**\n * Background\n */\n\nconst Background = () => {\n  // Parameters\n  const numberOfTetrahedra = 100;\n  const rotationSpeed = 0.005; // Ref\n\n  const mount = useRef(null); // Mount\n\n  useEffect(() => {\n    const div = mount.current;\n    let frameId;\n    let width = div.clientWidth;\n    let height = div.clientHeight; // Scene\n\n    const scene = new Scene(); // Camera\n\n    const camera = new PerspectiveCamera(10, width / height, 0.1, 1000);\n    camera.position.z = 10; // Renderer\n\n    const renderer = new WebGLRenderer({\n      antialias: true,\n      alpha: true,\n      powerPreference: 'low-power'\n    });\n    renderer.setClearColor('#ffffff', 0);\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(window.devicePixelRatio || 1); // Mount\n\n    div.appendChild(renderer.domElement); // Tetrahedra\n    // Rotations\n\n    const rotationX = [];\n    const rotationY = [];\n    const rotationZ = []; // Visible height & width\n\n    const offset = camera.position.z;\n    const hFOV = camera.fov * Math.PI / 180;\n    const h = 2 * Math.tan(hFOV / 2) * offset;\n    const w = h * camera.aspect; // Build tetra\n\n    for (let i = 0; i < numberOfTetrahedra; ++i) {\n      const rand = Math.random();\n      const material = new MeshBasicMaterial({\n        color: rand * 0x0096c7 + (1 - rand) * 0xffffff,\n        wireframe: true,\n        transparent: true,\n        opacity: 0.2\n      });\n      const geometry = new TetrahedronGeometry(0.1 * Math.random());\n      geometry.translate(-1.2 * w / 2 + 1.2 * w * Math.random(), -1.2 * h / 2 + 1.2 * h * Math.random(), 0);\n      geometry.lookAt(new Vector3(-1 + 2 * Math.random(), -1 + 2 * Math.random(), -1 + 2 * Math.random()));\n      rotationX.push(-rotationSpeed / 2 + rotationSpeed * Math.random());\n      rotationY.push(-rotationSpeed / 2 + rotationSpeed * Math.random());\n      rotationZ.push(-rotationSpeed / 2 + rotationSpeed * Math.random());\n      const mesh = new Mesh(geometry, material);\n      scene.add(mesh);\n    }\n    /**\n     * Resize\n     */\n\n\n    const resize = () => {\n      width = div.clientWidth;\n      height = div.clientHeight;\n      renderer.setSize(width, height);\n      camera.aspect = width / height;\n      camera.updateProjectionMatrix();\n    };\n    /**\n     * Render scene\n     */\n\n\n    const renderScene = () => {\n      scene.children.forEach((child, index) => {\n        child.rotation.x += rotationY[index];\n        child.rotation.y += rotationX[index];\n        child.rotation.z += rotationZ[index];\n      });\n      renderer.render(scene, camera);\n    };\n    /**\n     * Animate\n     */\n\n\n    const animate = () => {\n      renderScene();\n      frameId = requestAnimationFrame(animate);\n    };\n    /**\n     * Stop\n     */\n\n\n    const stop = () => {\n      cancelAnimationFrame(frameId);\n    }; // Start\n\n\n    animate(); // Event listener\n\n    window.addEventListener('resize', resize); // Unmount\n\n    return () => {\n      // Stop\n      stop(); // Remove event listener\n\n      window.removeEventListener('resize', resize); // Unmount renderer\n\n      div.removeChild(renderer.domElement); // Clear scene\n\n      scene.children.forEach(child => {\n        child.geometry.dispose();\n        child.material.dispose();\n        scene.remove(child);\n      });\n    };\n  }, []);\n  /**\n   * Render\n   */\n\n  return /*#__PURE__*/_jsx(\"div\", {\n    className: \"Background\",\n    ref: mount\n  });\n};\n\nexport default Background;","map":null,"metadata":{},"sourceType":"module"}