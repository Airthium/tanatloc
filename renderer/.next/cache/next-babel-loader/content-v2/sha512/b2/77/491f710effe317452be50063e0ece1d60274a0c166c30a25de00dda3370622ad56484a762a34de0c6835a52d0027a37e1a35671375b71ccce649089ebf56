{"ast":null,"code":"import { BoxBufferGeometry, BufferGeometry, Color, CylinderBufferGeometry, DoubleSide, Euler, Float32BufferAttribute, Line, LineBasicMaterial, Matrix4, Mesh, MeshBasicMaterial, Object3D, OctahedronBufferGeometry, PlaneBufferGeometry, Quaternion, Raycaster, SphereBufferGeometry, TorusBufferGeometry, Vector3 } from '../../../build/three.module.js';\n\nvar TransformControls = function (camera, domElement) {\n  if (domElement === undefined) {\n    console.warn('THREE.TransformControls: The second parameter \"domElement\" is now mandatory.');\n    domElement = document;\n  }\n\n  Object3D.call(this);\n  this.visible = false;\n  this.domElement = domElement;\n\n  var _gizmo = new TransformControlsGizmo();\n\n  this.add(_gizmo);\n\n  var _plane = new TransformControlsPlane();\n\n  this.add(_plane);\n  var scope = this; // Define properties with getters/setter\n  // Setting the defined property will automatically trigger change event\n  // Defined properties are passed down to gizmo and plane\n\n  defineProperty('camera', camera);\n  defineProperty('object', undefined);\n  defineProperty('enabled', true);\n  defineProperty('axis', null);\n  defineProperty('mode', 'translate');\n  defineProperty('translationSnap', null);\n  defineProperty('rotationSnap', null);\n  defineProperty('scaleSnap', null);\n  defineProperty('space', 'world');\n  defineProperty('size', 1);\n  defineProperty('dragging', false);\n  defineProperty('showX', true);\n  defineProperty('showY', true);\n  defineProperty('showZ', true);\n  var changeEvent = {\n    type: 'change'\n  };\n  var mouseDownEvent = {\n    type: 'mouseDown'\n  };\n  var mouseUpEvent = {\n    type: 'mouseUp',\n    mode: scope.mode\n  };\n  var objectChangeEvent = {\n    type: 'objectChange'\n  }; // Reusable utility variables\n\n  var raycaster = new Raycaster();\n\n  function intersectObjectWithRay(object, raycaster, includeInvisible) {\n    var allIntersections = raycaster.intersectObject(object, true);\n\n    for (var i = 0; i < allIntersections.length; i++) {\n      if (allIntersections[i].object.visible || includeInvisible) {\n        return allIntersections[i];\n      }\n    }\n\n    return false;\n  }\n\n  var _tempVector = new Vector3();\n\n  var _tempVector2 = new Vector3();\n\n  var _tempQuaternion = new Quaternion();\n\n  var _unit = {\n    X: new Vector3(1, 0, 0),\n    Y: new Vector3(0, 1, 0),\n    Z: new Vector3(0, 0, 1)\n  };\n  var pointStart = new Vector3();\n  var pointEnd = new Vector3();\n  var offset = new Vector3();\n  var rotationAxis = new Vector3();\n  var startNorm = new Vector3();\n  var endNorm = new Vector3();\n  var rotationAngle = 0;\n  var cameraPosition = new Vector3();\n  var cameraQuaternion = new Quaternion();\n  var cameraScale = new Vector3();\n  var parentPosition = new Vector3();\n  var parentQuaternion = new Quaternion();\n  var parentQuaternionInv = new Quaternion();\n  var parentScale = new Vector3();\n  var worldPositionStart = new Vector3();\n  var worldQuaternionStart = new Quaternion();\n  var worldScaleStart = new Vector3();\n  var worldPosition = new Vector3();\n  var worldQuaternion = new Quaternion();\n  var worldQuaternionInv = new Quaternion();\n  var worldScale = new Vector3();\n  var eye = new Vector3();\n  var positionStart = new Vector3();\n  var quaternionStart = new Quaternion();\n  var scaleStart = new Vector3(); // TODO: remove properties unused in plane and gizmo\n\n  defineProperty('worldPosition', worldPosition);\n  defineProperty('worldPositionStart', worldPositionStart);\n  defineProperty('worldQuaternion', worldQuaternion);\n  defineProperty('worldQuaternionStart', worldQuaternionStart);\n  defineProperty('cameraPosition', cameraPosition);\n  defineProperty('cameraQuaternion', cameraQuaternion);\n  defineProperty('pointStart', pointStart);\n  defineProperty('pointEnd', pointEnd);\n  defineProperty('rotationAxis', rotationAxis);\n  defineProperty('rotationAngle', rotationAngle);\n  defineProperty('eye', eye);\n  {\n    domElement.addEventListener('pointerdown', onPointerDown, false);\n    domElement.addEventListener('pointermove', onPointerHover, false);\n    scope.domElement.ownerDocument.addEventListener('pointerup', onPointerUp, false);\n  }\n\n  this.dispose = function () {\n    domElement.removeEventListener('pointerdown', onPointerDown);\n    domElement.removeEventListener('pointermove', onPointerHover);\n    scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove);\n    scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\n    this.traverse(function (child) {\n      if (child.geometry) child.geometry.dispose();\n      if (child.material) child.material.dispose();\n    });\n  }; // Set current object\n\n\n  this.attach = function (object) {\n    this.object = object;\n    this.visible = true;\n    return this;\n  }; // Detatch from object\n\n\n  this.detach = function () {\n    this.object = undefined;\n    this.visible = false;\n    this.axis = null;\n    return this;\n  }; // Defined getter, setter and store for a property\n\n\n  function defineProperty(propName, defaultValue) {\n    var propValue = defaultValue;\n    Object.defineProperty(scope, propName, {\n      get: function () {\n        return propValue !== undefined ? propValue : defaultValue;\n      },\n      set: function (value) {\n        if (propValue !== value) {\n          propValue = value;\n          _plane[propName] = value;\n          _gizmo[propName] = value;\n          scope.dispatchEvent({\n            type: propName + '-changed',\n            value: value\n          });\n          scope.dispatchEvent(changeEvent);\n        }\n      }\n    });\n    scope[propName] = defaultValue;\n    _plane[propName] = defaultValue;\n    _gizmo[propName] = defaultValue;\n  } // updateMatrixWorld  updates key transformation variables\n\n\n  this.updateMatrixWorld = function () {\n    if (this.object !== undefined) {\n      this.object.updateMatrixWorld();\n\n      if (this.object.parent === null) {\n        console.error('TransformControls: The attached 3D object must be a part of the scene graph.');\n      } else {\n        this.object.parent.matrixWorld.decompose(parentPosition, parentQuaternion, parentScale);\n      }\n\n      this.object.matrixWorld.decompose(worldPosition, worldQuaternion, worldScale);\n      parentQuaternionInv.copy(parentQuaternion).invert();\n      worldQuaternionInv.copy(worldQuaternion).invert();\n    }\n\n    this.camera.updateMatrixWorld();\n    this.camera.matrixWorld.decompose(cameraPosition, cameraQuaternion, cameraScale);\n    eye.copy(cameraPosition).sub(worldPosition).normalize();\n    Object3D.prototype.updateMatrixWorld.call(this);\n  };\n\n  this.pointerHover = function (pointer) {\n    if (this.object === undefined || this.dragging === true) return;\n    raycaster.setFromCamera(pointer, this.camera);\n    var intersect = intersectObjectWithRay(_gizmo.picker[this.mode], raycaster);\n\n    if (intersect) {\n      this.axis = intersect.object.name;\n    } else {\n      this.axis = null;\n    }\n  };\n\n  this.pointerDown = function (pointer) {\n    if (this.object === undefined || this.dragging === true || pointer.button !== 0) return;\n\n    if (this.axis !== null) {\n      raycaster.setFromCamera(pointer, this.camera);\n      var planeIntersect = intersectObjectWithRay(_plane, raycaster, true);\n\n      if (planeIntersect) {\n        var space = this.space;\n\n        if (this.mode === 'scale') {\n          space = 'local';\n        } else if (this.axis === 'E' || this.axis === 'XYZE' || this.axis === 'XYZ') {\n          space = 'world';\n        }\n\n        if (space === 'local' && this.mode === 'rotate') {\n          var snap = this.rotationSnap;\n          if (this.axis === 'X' && snap) this.object.rotation.x = Math.round(this.object.rotation.x / snap) * snap;\n          if (this.axis === 'Y' && snap) this.object.rotation.y = Math.round(this.object.rotation.y / snap) * snap;\n          if (this.axis === 'Z' && snap) this.object.rotation.z = Math.round(this.object.rotation.z / snap) * snap;\n        }\n\n        this.object.updateMatrixWorld();\n        this.object.parent.updateMatrixWorld();\n        positionStart.copy(this.object.position);\n        quaternionStart.copy(this.object.quaternion);\n        scaleStart.copy(this.object.scale);\n        this.object.matrixWorld.decompose(worldPositionStart, worldQuaternionStart, worldScaleStart);\n        pointStart.copy(planeIntersect.point).sub(worldPositionStart);\n      }\n\n      this.dragging = true;\n      mouseDownEvent.mode = this.mode;\n      this.dispatchEvent(mouseDownEvent);\n    }\n  };\n\n  this.pointerMove = function (pointer) {\n    var axis = this.axis;\n    var mode = this.mode;\n    var object = this.object;\n    var space = this.space;\n\n    if (mode === 'scale') {\n      space = 'local';\n    } else if (axis === 'E' || axis === 'XYZE' || axis === 'XYZ') {\n      space = 'world';\n    }\n\n    if (object === undefined || axis === null || this.dragging === false || pointer.button !== -1) return;\n    raycaster.setFromCamera(pointer, this.camera);\n    var planeIntersect = intersectObjectWithRay(_plane, raycaster, true);\n    if (!planeIntersect) return;\n    pointEnd.copy(planeIntersect.point).sub(worldPositionStart);\n\n    if (mode === 'translate') {\n      // Apply translate\n      offset.copy(pointEnd).sub(pointStart);\n\n      if (space === 'local' && axis !== 'XYZ') {\n        offset.applyQuaternion(worldQuaternionInv);\n      }\n\n      if (axis.indexOf('X') === -1) offset.x = 0;\n      if (axis.indexOf('Y') === -1) offset.y = 0;\n      if (axis.indexOf('Z') === -1) offset.z = 0;\n\n      if (space === 'local' && axis !== 'XYZ') {\n        offset.applyQuaternion(quaternionStart).divide(parentScale);\n      } else {\n        offset.applyQuaternion(parentQuaternionInv).divide(parentScale);\n      }\n\n      object.position.copy(offset).add(positionStart); // Apply translation snap\n\n      if (this.translationSnap) {\n        if (space === 'local') {\n          object.position.applyQuaternion(_tempQuaternion.copy(quaternionStart).invert());\n\n          if (axis.search('X') !== -1) {\n            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;\n          }\n\n          if (axis.search('Y') !== -1) {\n            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;\n          }\n\n          if (axis.search('Z') !== -1) {\n            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;\n          }\n\n          object.position.applyQuaternion(quaternionStart);\n        }\n\n        if (space === 'world') {\n          if (object.parent) {\n            object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));\n          }\n\n          if (axis.search('X') !== -1) {\n            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;\n          }\n\n          if (axis.search('Y') !== -1) {\n            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;\n          }\n\n          if (axis.search('Z') !== -1) {\n            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;\n          }\n\n          if (object.parent) {\n            object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));\n          }\n        }\n      }\n    } else if (mode === 'scale') {\n      if (axis.search('XYZ') !== -1) {\n        var d = pointEnd.length() / pointStart.length();\n        if (pointEnd.dot(pointStart) < 0) d *= -1;\n\n        _tempVector2.set(d, d, d);\n      } else {\n        _tempVector.copy(pointStart);\n\n        _tempVector2.copy(pointEnd);\n\n        _tempVector.applyQuaternion(worldQuaternionInv);\n\n        _tempVector2.applyQuaternion(worldQuaternionInv);\n\n        _tempVector2.divide(_tempVector);\n\n        if (axis.search('X') === -1) {\n          _tempVector2.x = 1;\n        }\n\n        if (axis.search('Y') === -1) {\n          _tempVector2.y = 1;\n        }\n\n        if (axis.search('Z') === -1) {\n          _tempVector2.z = 1;\n        }\n      } // Apply scale\n\n\n      object.scale.copy(scaleStart).multiply(_tempVector2);\n\n      if (this.scaleSnap) {\n        if (axis.search('X') !== -1) {\n          object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;\n        }\n\n        if (axis.search('Y') !== -1) {\n          object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;\n        }\n\n        if (axis.search('Z') !== -1) {\n          object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;\n        }\n      }\n    } else if (mode === 'rotate') {\n      offset.copy(pointEnd).sub(pointStart);\n      var ROTATION_SPEED = 20 / worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));\n\n      if (axis === 'E') {\n        rotationAxis.copy(eye);\n        rotationAngle = pointEnd.angleTo(pointStart);\n        startNorm.copy(pointStart).normalize();\n        endNorm.copy(pointEnd).normalize();\n        rotationAngle *= endNorm.cross(startNorm).dot(eye) < 0 ? 1 : -1;\n      } else if (axis === 'XYZE') {\n        rotationAxis.copy(offset).cross(eye).normalize();\n        rotationAngle = offset.dot(_tempVector.copy(rotationAxis).cross(this.eye)) * ROTATION_SPEED;\n      } else if (axis === 'X' || axis === 'Y' || axis === 'Z') {\n        rotationAxis.copy(_unit[axis]);\n\n        _tempVector.copy(_unit[axis]);\n\n        if (space === 'local') {\n          _tempVector.applyQuaternion(worldQuaternion);\n        }\n\n        rotationAngle = offset.dot(_tempVector.cross(eye).normalize()) * ROTATION_SPEED;\n      } // Apply rotation snap\n\n\n      if (this.rotationSnap) rotationAngle = Math.round(rotationAngle / this.rotationSnap) * this.rotationSnap;\n      this.rotationAngle = rotationAngle; // Apply rotate\n\n      if (space === 'local' && axis !== 'E' && axis !== 'XYZE') {\n        object.quaternion.copy(quaternionStart);\n        object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(rotationAxis, rotationAngle)).normalize();\n      } else {\n        rotationAxis.applyQuaternion(parentQuaternionInv);\n        object.quaternion.copy(_tempQuaternion.setFromAxisAngle(rotationAxis, rotationAngle));\n        object.quaternion.multiply(quaternionStart).normalize();\n      }\n    }\n\n    this.dispatchEvent(changeEvent);\n    this.dispatchEvent(objectChangeEvent);\n  };\n\n  this.pointerUp = function (pointer) {\n    if (pointer.button !== 0) return;\n\n    if (this.dragging && this.axis !== null) {\n      mouseUpEvent.mode = this.mode;\n      this.dispatchEvent(mouseUpEvent);\n    }\n\n    this.dragging = false;\n    this.axis = null;\n  }; // normalize mouse / touch pointer and remap {x,y} to view space.\n\n\n  function getPointer(event) {\n    if (scope.domElement.ownerDocument.pointerLockElement) {\n      return {\n        x: 0,\n        y: 0,\n        button: event.button\n      };\n    } else {\n      var pointer = event.changedTouches ? event.changedTouches[0] : event;\n      var rect = domElement.getBoundingClientRect();\n      return {\n        x: (pointer.clientX - rect.left) / rect.width * 2 - 1,\n        y: -(pointer.clientY - rect.top) / rect.height * 2 + 1,\n        button: event.button\n      };\n    }\n  } // mouse / touch event handlers\n\n\n  function onPointerHover(event) {\n    if (!scope.enabled) return;\n\n    switch (event.pointerType) {\n      case 'mouse':\n      case 'pen':\n        scope.pointerHover(getPointer(event));\n        break;\n    }\n  }\n\n  function onPointerDown(event) {\n    if (!scope.enabled) return;\n    scope.domElement.style.touchAction = 'none'; // disable touch scroll\n\n    scope.domElement.ownerDocument.addEventListener('pointermove', onPointerMove, false);\n    scope.pointerHover(getPointer(event));\n    scope.pointerDown(getPointer(event));\n  }\n\n  function onPointerMove(event) {\n    if (!scope.enabled) return;\n    scope.pointerMove(getPointer(event));\n  }\n\n  function onPointerUp(event) {\n    if (!scope.enabled) return;\n    scope.domElement.style.touchAction = '';\n    scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, false);\n    scope.pointerUp(getPointer(event));\n  } // TODO: deprecate\n\n\n  this.getMode = function () {\n    return scope.mode;\n  };\n\n  this.setMode = function (mode) {\n    scope.mode = mode;\n  };\n\n  this.setTranslationSnap = function (translationSnap) {\n    scope.translationSnap = translationSnap;\n  };\n\n  this.setRotationSnap = function (rotationSnap) {\n    scope.rotationSnap = rotationSnap;\n  };\n\n  this.setScaleSnap = function (scaleSnap) {\n    scope.scaleSnap = scaleSnap;\n  };\n\n  this.setSize = function (size) {\n    scope.size = size;\n  };\n\n  this.setSpace = function (space) {\n    scope.space = space;\n  };\n\n  this.update = function () {\n    console.warn('THREE.TransformControls: update function has no more functionality and therefore has been deprecated.');\n  };\n};\n\nTransformControls.prototype = Object.assign(Object.create(Object3D.prototype), {\n  constructor: TransformControls,\n  isTransformControls: true\n});\n\nvar TransformControlsGizmo = function () {\n  'use strict';\n\n  Object3D.call(this);\n  this.type = 'TransformControlsGizmo'; // shared materials\n\n  var gizmoMaterial = new MeshBasicMaterial({\n    depthTest: false,\n    depthWrite: false,\n    transparent: true,\n    side: DoubleSide,\n    fog: false,\n    toneMapped: false\n  });\n  var gizmoLineMaterial = new LineBasicMaterial({\n    depthTest: false,\n    depthWrite: false,\n    transparent: true,\n    linewidth: 1,\n    fog: false,\n    toneMapped: false\n  }); // Make unique material for each axis/color\n\n  var matInvisible = gizmoMaterial.clone();\n  matInvisible.opacity = 0.15;\n  var matHelper = gizmoMaterial.clone();\n  matHelper.opacity = 0.33;\n  var matRed = gizmoMaterial.clone();\n  matRed.color.set(0xff0000);\n  var matGreen = gizmoMaterial.clone();\n  matGreen.color.set(0x00ff00);\n  var matBlue = gizmoMaterial.clone();\n  matBlue.color.set(0x0000ff);\n  var matWhiteTransparent = gizmoMaterial.clone();\n  matWhiteTransparent.opacity = 0.25;\n  var matYellowTransparent = matWhiteTransparent.clone();\n  matYellowTransparent.color.set(0xffff00);\n  var matCyanTransparent = matWhiteTransparent.clone();\n  matCyanTransparent.color.set(0x00ffff);\n  var matMagentaTransparent = matWhiteTransparent.clone();\n  matMagentaTransparent.color.set(0xff00ff);\n  var matYellow = gizmoMaterial.clone();\n  matYellow.color.set(0xffff00);\n  var matLineRed = gizmoLineMaterial.clone();\n  matLineRed.color.set(0xff0000);\n  var matLineGreen = gizmoLineMaterial.clone();\n  matLineGreen.color.set(0x00ff00);\n  var matLineBlue = gizmoLineMaterial.clone();\n  matLineBlue.color.set(0x0000ff);\n  var matLineCyan = gizmoLineMaterial.clone();\n  matLineCyan.color.set(0x00ffff);\n  var matLineMagenta = gizmoLineMaterial.clone();\n  matLineMagenta.color.set(0xff00ff);\n  var matLineYellow = gizmoLineMaterial.clone();\n  matLineYellow.color.set(0xffff00);\n  var matLineGray = gizmoLineMaterial.clone();\n  matLineGray.color.set(0x787878);\n  var matLineYellowTransparent = matLineYellow.clone();\n  matLineYellowTransparent.opacity = 0.25; // reusable geometry\n\n  var arrowGeometry = new CylinderBufferGeometry(0, 0.05, 0.2, 12, 1, false);\n  var scaleHandleGeometry = new BoxBufferGeometry(0.125, 0.125, 0.125);\n  var lineGeometry = new BufferGeometry();\n  lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));\n\n  var CircleGeometry = function (radius, arc) {\n    var geometry = new BufferGeometry();\n    var vertices = [];\n\n    for (var i = 0; i <= 64 * arc; ++i) {\n      vertices.push(0, Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius);\n    }\n\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    return geometry;\n  }; // Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position\n\n\n  var TranslateHelperGeometry = function () {\n    var geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));\n    return geometry;\n  }; // Gizmo definitions - custom hierarchy definitions for setupGizmo() function\n\n\n  var gizmoTranslate = {\n    X: [[new Mesh(arrowGeometry, matRed), [1, 0, 0], [0, 0, -Math.PI / 2], null, 'fwd'], [new Mesh(arrowGeometry, matRed), [1, 0, 0], [0, 0, Math.PI / 2], null, 'bwd'], [new Line(lineGeometry, matLineRed)]],\n    Y: [[new Mesh(arrowGeometry, matGreen), [0, 1, 0], null, null, 'fwd'], [new Mesh(arrowGeometry, matGreen), [0, 1, 0], [Math.PI, 0, 0], null, 'bwd'], [new Line(lineGeometry, matLineGreen), null, [0, 0, Math.PI / 2]]],\n    Z: [[new Mesh(arrowGeometry, matBlue), [0, 0, 1], [Math.PI / 2, 0, 0], null, 'fwd'], [new Mesh(arrowGeometry, matBlue), [0, 0, 1], [-Math.PI / 2, 0, 0], null, 'bwd'], [new Line(lineGeometry, matLineBlue), null, [0, -Math.PI / 2, 0]]],\n    XYZ: [[new Mesh(new OctahedronBufferGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0], [0, 0, 0]]],\n    XY: [[new Mesh(new PlaneBufferGeometry(0.295, 0.295), matYellowTransparent.clone()), [0.15, 0.15, 0]], [new Line(lineGeometry, matLineYellow), [0.18, 0.3, 0], null, [0.125, 1, 1]], [new Line(lineGeometry, matLineYellow), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]],\n    YZ: [[new Mesh(new PlaneBufferGeometry(0.295, 0.295), matCyanTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]], [new Line(lineGeometry, matLineCyan), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]], [new Line(lineGeometry, matLineCyan), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],\n    XZ: [[new Mesh(new PlaneBufferGeometry(0.295, 0.295), matMagentaTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]], [new Line(lineGeometry, matLineMagenta), [0.18, 0, 0.3], null, [0.125, 1, 1]], [new Line(lineGeometry, matLineMagenta), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]]\n  };\n  var pickerTranslate = {\n    X: [[new Mesh(new CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), matInvisible), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],\n    Y: [[new Mesh(new CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), matInvisible), [0, 0.6, 0]]],\n    Z: [[new Mesh(new CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), matInvisible), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],\n    XYZ: [[new Mesh(new OctahedronBufferGeometry(0.2, 0), matInvisible)]],\n    XY: [[new Mesh(new PlaneBufferGeometry(0.4, 0.4), matInvisible), [0.2, 0.2, 0]]],\n    YZ: [[new Mesh(new PlaneBufferGeometry(0.4, 0.4), matInvisible), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],\n    XZ: [[new Mesh(new PlaneBufferGeometry(0.4, 0.4), matInvisible), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]\n  };\n  var helperTranslate = {\n    START: [[new Mesh(new OctahedronBufferGeometry(0.01, 2), matHelper), null, null, null, 'helper']],\n    END: [[new Mesh(new OctahedronBufferGeometry(0.01, 2), matHelper), null, null, null, 'helper']],\n    DELTA: [[new Line(TranslateHelperGeometry(), matHelper), null, null, null, 'helper']],\n    X: [[new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']],\n    Y: [[new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], 'helper']],\n    Z: [[new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], 'helper']]\n  };\n  var gizmoRotate = {\n    X: [[new Line(CircleGeometry(1, 0.5), matLineRed)], [new Mesh(new OctahedronBufferGeometry(0.04, 0), matRed), [0, 0, 0.99], null, [1, 3, 1]]],\n    Y: [[new Line(CircleGeometry(1, 0.5), matLineGreen), null, [0, 0, -Math.PI / 2]], [new Mesh(new OctahedronBufferGeometry(0.04, 0), matGreen), [0, 0, 0.99], null, [3, 1, 1]]],\n    Z: [[new Line(CircleGeometry(1, 0.5), matLineBlue), null, [0, Math.PI / 2, 0]], [new Mesh(new OctahedronBufferGeometry(0.04, 0), matBlue), [0.99, 0, 0], null, [1, 3, 1]]],\n    E: [[new Line(CircleGeometry(1.25, 1), matLineYellowTransparent), null, [0, Math.PI / 2, 0]], [new Mesh(new CylinderBufferGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [1.17, 0, 0], [0, 0, -Math.PI / 2], [1, 1, 0.001]], [new Mesh(new CylinderBufferGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [-1.17, 0, 0], [0, 0, Math.PI / 2], [1, 1, 0.001]], [new Mesh(new CylinderBufferGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [0, -1.17, 0], [Math.PI, 0, 0], [1, 1, 0.001]], [new Mesh(new CylinderBufferGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [0, 1.17, 0], [0, 0, 0], [1, 1, 0.001]]],\n    XYZE: [[new Line(CircleGeometry(1, 1), matLineGray), null, [0, Math.PI / 2, 0]]]\n  };\n  var helperRotate = {\n    AXIS: [[new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']]\n  };\n  var pickerRotate = {\n    X: [[new Mesh(new TorusBufferGeometry(1, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],\n    Y: [[new Mesh(new TorusBufferGeometry(1, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]],\n    Z: [[new Mesh(new TorusBufferGeometry(1, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]],\n    E: [[new Mesh(new TorusBufferGeometry(1.25, 0.1, 2, 24), matInvisible)]],\n    XYZE: [[new Mesh(new SphereBufferGeometry(0.7, 10, 8), matInvisible)]]\n  };\n  var gizmoScale = {\n    X: [[new Mesh(scaleHandleGeometry, matRed), [0.8, 0, 0], [0, 0, -Math.PI / 2]], [new Line(lineGeometry, matLineRed), null, null, [0.8, 1, 1]]],\n    Y: [[new Mesh(scaleHandleGeometry, matGreen), [0, 0.8, 0]], [new Line(lineGeometry, matLineGreen), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]],\n    Z: [[new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.8], [Math.PI / 2, 0, 0]], [new Line(lineGeometry, matLineBlue), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]],\n    XY: [[new Mesh(scaleHandleGeometry, matYellowTransparent), [0.85, 0.85, 0], null, [2, 2, 0.2]], [new Line(lineGeometry, matLineYellow), [0.855, 0.98, 0], null, [0.125, 1, 1]], [new Line(lineGeometry, matLineYellow), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]],\n    YZ: [[new Mesh(scaleHandleGeometry, matCyanTransparent), [0, 0.85, 0.85], null, [0.2, 2, 2]], [new Line(lineGeometry, matLineCyan), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]], [new Line(lineGeometry, matLineCyan), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],\n    XZ: [[new Mesh(scaleHandleGeometry, matMagentaTransparent), [0.85, 0, 0.85], null, [2, 0.2, 2]], [new Line(lineGeometry, matLineMagenta), [0.855, 0, 0.98], null, [0.125, 1, 1]], [new Line(lineGeometry, matLineMagenta), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],\n    XYZX: [[new Mesh(new BoxBufferGeometry(0.125, 0.125, 0.125), matWhiteTransparent.clone()), [1.1, 0, 0]]],\n    XYZY: [[new Mesh(new BoxBufferGeometry(0.125, 0.125, 0.125), matWhiteTransparent.clone()), [0, 1.1, 0]]],\n    XYZZ: [[new Mesh(new BoxBufferGeometry(0.125, 0.125, 0.125), matWhiteTransparent.clone()), [0, 0, 1.1]]]\n  };\n  var pickerScale = {\n    X: [[new Mesh(new CylinderBufferGeometry(0.2, 0, 0.8, 4, 1, false), matInvisible), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],\n    Y: [[new Mesh(new CylinderBufferGeometry(0.2, 0, 0.8, 4, 1, false), matInvisible), [0, 0.5, 0]]],\n    Z: [[new Mesh(new CylinderBufferGeometry(0.2, 0, 0.8, 4, 1, false), matInvisible), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],\n    XY: [[new Mesh(scaleHandleGeometry, matInvisible), [0.85, 0.85, 0], null, [3, 3, 0.2]]],\n    YZ: [[new Mesh(scaleHandleGeometry, matInvisible), [0, 0.85, 0.85], null, [0.2, 3, 3]]],\n    XZ: [[new Mesh(scaleHandleGeometry, matInvisible), [0.85, 0, 0.85], null, [3, 0.2, 3]]],\n    XYZX: [[new Mesh(new BoxBufferGeometry(0.2, 0.2, 0.2), matInvisible), [1.1, 0, 0]]],\n    XYZY: [[new Mesh(new BoxBufferGeometry(0.2, 0.2, 0.2), matInvisible), [0, 1.1, 0]]],\n    XYZZ: [[new Mesh(new BoxBufferGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 1.1]]]\n  };\n  var helperScale = {\n    X: [[new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']],\n    Y: [[new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], 'helper']],\n    Z: [[new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], 'helper']]\n  }; // Creates an Object3D with gizmos described in custom hierarchy definition.\n\n  var setupGizmo = function (gizmoMap) {\n    var gizmo = new Object3D();\n\n    for (var name in gizmoMap) {\n      for (var i = gizmoMap[name].length; i--;) {\n        var object = gizmoMap[name][i][0].clone();\n        var position = gizmoMap[name][i][1];\n        var rotation = gizmoMap[name][i][2];\n        var scale = gizmoMap[name][i][3];\n        var tag = gizmoMap[name][i][4]; // name and tag properties are essential for picking and updating logic.\n\n        object.name = name;\n        object.tag = tag;\n\n        if (position) {\n          object.position.set(position[0], position[1], position[2]);\n        }\n\n        if (rotation) {\n          object.rotation.set(rotation[0], rotation[1], rotation[2]);\n        }\n\n        if (scale) {\n          object.scale.set(scale[0], scale[1], scale[2]);\n        }\n\n        object.updateMatrix();\n        var tempGeometry = object.geometry.clone();\n        tempGeometry.applyMatrix4(object.matrix);\n        object.geometry = tempGeometry;\n        object.renderOrder = Infinity;\n        object.position.set(0, 0, 0);\n        object.rotation.set(0, 0, 0);\n        object.scale.set(1, 1, 1);\n        gizmo.add(object);\n      }\n    }\n\n    return gizmo;\n  }; // Reusable utility variables\n\n\n  var tempVector = new Vector3(0, 0, 0);\n  var tempEuler = new Euler();\n  var alignVector = new Vector3(0, 1, 0);\n  var zeroVector = new Vector3(0, 0, 0);\n  var lookAtMatrix = new Matrix4();\n  var tempQuaternion = new Quaternion();\n  var tempQuaternion2 = new Quaternion();\n  var identityQuaternion = new Quaternion();\n  var unitX = new Vector3(1, 0, 0);\n  var unitY = new Vector3(0, 1, 0);\n  var unitZ = new Vector3(0, 0, 1); // Gizmo creation\n\n  this.gizmo = {};\n  this.picker = {};\n  this.helper = {};\n  this.add(this.gizmo['translate'] = setupGizmo(gizmoTranslate));\n  this.add(this.gizmo['rotate'] = setupGizmo(gizmoRotate));\n  this.add(this.gizmo['scale'] = setupGizmo(gizmoScale));\n  this.add(this.picker['translate'] = setupGizmo(pickerTranslate));\n  this.add(this.picker['rotate'] = setupGizmo(pickerRotate));\n  this.add(this.picker['scale'] = setupGizmo(pickerScale));\n  this.add(this.helper['translate'] = setupGizmo(helperTranslate));\n  this.add(this.helper['rotate'] = setupGizmo(helperRotate));\n  this.add(this.helper['scale'] = setupGizmo(helperScale)); // Pickers should be hidden always\n\n  this.picker['translate'].visible = false;\n  this.picker['rotate'].visible = false;\n  this.picker['scale'].visible = false; // updateMatrixWorld will update transformations and appearance of individual handles\n\n  this.updateMatrixWorld = function () {\n    var space = this.space;\n    if (this.mode === 'scale') space = 'local'; // scale always oriented to local rotation\n\n    var quaternion = space === 'local' ? this.worldQuaternion : identityQuaternion; // Show only gizmos for current transform mode\n\n    this.gizmo['translate'].visible = this.mode === 'translate';\n    this.gizmo['rotate'].visible = this.mode === 'rotate';\n    this.gizmo['scale'].visible = this.mode === 'scale';\n    this.helper['translate'].visible = this.mode === 'translate';\n    this.helper['rotate'].visible = this.mode === 'rotate';\n    this.helper['scale'].visible = this.mode === 'scale';\n    var handles = [];\n    handles = handles.concat(this.picker[this.mode].children);\n    handles = handles.concat(this.gizmo[this.mode].children);\n    handles = handles.concat(this.helper[this.mode].children);\n\n    for (var i = 0; i < handles.length; i++) {\n      var handle = handles[i]; // hide aligned to camera\n\n      handle.visible = true;\n      handle.rotation.set(0, 0, 0);\n      handle.position.copy(this.worldPosition);\n      var factor;\n\n      if (this.camera.isOrthographicCamera) {\n        factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;\n      } else {\n        factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);\n      }\n\n      handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 7); // TODO: simplify helpers and consider decoupling from gizmo\n\n      if (handle.tag === 'helper') {\n        handle.visible = false;\n\n        if (handle.name === 'AXIS') {\n          handle.position.copy(this.worldPositionStart);\n          handle.visible = !!this.axis;\n\n          if (this.axis === 'X') {\n            tempQuaternion.setFromEuler(tempEuler.set(0, 0, 0));\n            handle.quaternion.copy(quaternion).multiply(tempQuaternion);\n\n            if (Math.abs(alignVector.copy(unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {\n              handle.visible = false;\n            }\n          }\n\n          if (this.axis === 'Y') {\n            tempQuaternion.setFromEuler(tempEuler.set(0, 0, Math.PI / 2));\n            handle.quaternion.copy(quaternion).multiply(tempQuaternion);\n\n            if (Math.abs(alignVector.copy(unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {\n              handle.visible = false;\n            }\n          }\n\n          if (this.axis === 'Z') {\n            tempQuaternion.setFromEuler(tempEuler.set(0, Math.PI / 2, 0));\n            handle.quaternion.copy(quaternion).multiply(tempQuaternion);\n\n            if (Math.abs(alignVector.copy(unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {\n              handle.visible = false;\n            }\n          }\n\n          if (this.axis === 'XYZE') {\n            tempQuaternion.setFromEuler(tempEuler.set(0, Math.PI / 2, 0));\n            alignVector.copy(this.rotationAxis);\n            handle.quaternion.setFromRotationMatrix(lookAtMatrix.lookAt(zeroVector, alignVector, unitY));\n            handle.quaternion.multiply(tempQuaternion);\n            handle.visible = this.dragging;\n          }\n\n          if (this.axis === 'E') {\n            handle.visible = false;\n          }\n        } else if (handle.name === 'START') {\n          handle.position.copy(this.worldPositionStart);\n          handle.visible = this.dragging;\n        } else if (handle.name === 'END') {\n          handle.position.copy(this.worldPosition);\n          handle.visible = this.dragging;\n        } else if (handle.name === 'DELTA') {\n          handle.position.copy(this.worldPositionStart);\n          handle.quaternion.copy(this.worldQuaternionStart);\n          tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);\n          tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());\n          handle.scale.copy(tempVector);\n          handle.visible = this.dragging;\n        } else {\n          handle.quaternion.copy(quaternion);\n\n          if (this.dragging) {\n            handle.position.copy(this.worldPositionStart);\n          } else {\n            handle.position.copy(this.worldPosition);\n          }\n\n          if (this.axis) {\n            handle.visible = this.axis.search(handle.name) !== -1;\n          }\n        } // If updating helper, skip rest of the loop\n\n\n        continue;\n      } // Align handles to current local or world rotation\n\n\n      handle.quaternion.copy(quaternion);\n\n      if (this.mode === 'translate' || this.mode === 'scale') {\n        // Hide translate and scale axis facing the camera\n        var AXIS_HIDE_TRESHOLD = 0.99;\n        var PLANE_HIDE_TRESHOLD = 0.2;\n        var AXIS_FLIP_TRESHOLD = 0.0;\n\n        if (handle.name === 'X' || handle.name === 'XYZX') {\n          if (Math.abs(alignVector.copy(unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {\n            handle.scale.set(1e-10, 1e-10, 1e-10);\n            handle.visible = false;\n          }\n        }\n\n        if (handle.name === 'Y' || handle.name === 'XYZY') {\n          if (Math.abs(alignVector.copy(unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {\n            handle.scale.set(1e-10, 1e-10, 1e-10);\n            handle.visible = false;\n          }\n        }\n\n        if (handle.name === 'Z' || handle.name === 'XYZZ') {\n          if (Math.abs(alignVector.copy(unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {\n            handle.scale.set(1e-10, 1e-10, 1e-10);\n            handle.visible = false;\n          }\n        }\n\n        if (handle.name === 'XY') {\n          if (Math.abs(alignVector.copy(unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {\n            handle.scale.set(1e-10, 1e-10, 1e-10);\n            handle.visible = false;\n          }\n        }\n\n        if (handle.name === 'YZ') {\n          if (Math.abs(alignVector.copy(unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {\n            handle.scale.set(1e-10, 1e-10, 1e-10);\n            handle.visible = false;\n          }\n        }\n\n        if (handle.name === 'XZ') {\n          if (Math.abs(alignVector.copy(unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {\n            handle.scale.set(1e-10, 1e-10, 1e-10);\n            handle.visible = false;\n          }\n        } // Flip translate and scale axis ocluded behind another axis\n\n\n        if (handle.name.search('X') !== -1) {\n          if (alignVector.copy(unitX).applyQuaternion(quaternion).dot(this.eye) < AXIS_FLIP_TRESHOLD) {\n            if (handle.tag === 'fwd') {\n              handle.visible = false;\n            } else {\n              handle.scale.x *= -1;\n            }\n          } else if (handle.tag === 'bwd') {\n            handle.visible = false;\n          }\n        }\n\n        if (handle.name.search('Y') !== -1) {\n          if (alignVector.copy(unitY).applyQuaternion(quaternion).dot(this.eye) < AXIS_FLIP_TRESHOLD) {\n            if (handle.tag === 'fwd') {\n              handle.visible = false;\n            } else {\n              handle.scale.y *= -1;\n            }\n          } else if (handle.tag === 'bwd') {\n            handle.visible = false;\n          }\n        }\n\n        if (handle.name.search('Z') !== -1) {\n          if (alignVector.copy(unitZ).applyQuaternion(quaternion).dot(this.eye) < AXIS_FLIP_TRESHOLD) {\n            if (handle.tag === 'fwd') {\n              handle.visible = false;\n            } else {\n              handle.scale.z *= -1;\n            }\n          } else if (handle.tag === 'bwd') {\n            handle.visible = false;\n          }\n        }\n      } else if (this.mode === 'rotate') {\n        // Align handles to current local or world rotation\n        tempQuaternion2.copy(quaternion);\n        alignVector.copy(this.eye).applyQuaternion(tempQuaternion.copy(quaternion).invert());\n\n        if (handle.name.search('E') !== -1) {\n          handle.quaternion.setFromRotationMatrix(lookAtMatrix.lookAt(this.eye, zeroVector, unitY));\n        }\n\n        if (handle.name === 'X') {\n          tempQuaternion.setFromAxisAngle(unitX, Math.atan2(-alignVector.y, alignVector.z));\n          tempQuaternion.multiplyQuaternions(tempQuaternion2, tempQuaternion);\n          handle.quaternion.copy(tempQuaternion);\n        }\n\n        if (handle.name === 'Y') {\n          tempQuaternion.setFromAxisAngle(unitY, Math.atan2(alignVector.x, alignVector.z));\n          tempQuaternion.multiplyQuaternions(tempQuaternion2, tempQuaternion);\n          handle.quaternion.copy(tempQuaternion);\n        }\n\n        if (handle.name === 'Z') {\n          tempQuaternion.setFromAxisAngle(unitZ, Math.atan2(alignVector.y, alignVector.x));\n          tempQuaternion.multiplyQuaternions(tempQuaternion2, tempQuaternion);\n          handle.quaternion.copy(tempQuaternion);\n        }\n      } // Hide disabled axes\n\n\n      handle.visible = handle.visible && (handle.name.indexOf('X') === -1 || this.showX);\n      handle.visible = handle.visible && (handle.name.indexOf('Y') === -1 || this.showY);\n      handle.visible = handle.visible && (handle.name.indexOf('Z') === -1 || this.showZ);\n      handle.visible = handle.visible && (handle.name.indexOf('E') === -1 || this.showX && this.showY && this.showZ); // highlight selected axis\n\n      handle.material._opacity = handle.material._opacity || handle.material.opacity;\n      handle.material._color = handle.material._color || handle.material.color.clone();\n      handle.material.color.copy(handle.material._color);\n      handle.material.opacity = handle.material._opacity;\n\n      if (!this.enabled) {\n        handle.material.opacity *= 0.5;\n        handle.material.color.lerp(new Color(1, 1, 1), 0.5);\n      } else if (this.axis) {\n        if (handle.name === this.axis) {\n          handle.material.opacity = 1.0;\n          handle.material.color.lerp(new Color(1, 1, 1), 0.5);\n        } else if (this.axis.split('').some(function (a) {\n          return handle.name === a;\n        })) {\n          handle.material.opacity = 1.0;\n          handle.material.color.lerp(new Color(1, 1, 1), 0.5);\n        } else {\n          handle.material.opacity *= 0.25;\n          handle.material.color.lerp(new Color(1, 1, 1), 0.5);\n        }\n      }\n    }\n\n    Object3D.prototype.updateMatrixWorld.call(this);\n  };\n};\n\nTransformControlsGizmo.prototype = Object.assign(Object.create(Object3D.prototype), {\n  constructor: TransformControlsGizmo,\n  isTransformControlsGizmo: true\n});\n\nvar TransformControlsPlane = function () {\n  'use strict';\n\n  Mesh.call(this, new PlaneBufferGeometry(100000, 100000, 2, 2), new MeshBasicMaterial({\n    visible: false,\n    wireframe: true,\n    side: DoubleSide,\n    transparent: true,\n    opacity: 0.1,\n    toneMapped: false\n  }));\n  this.type = 'TransformControlsPlane';\n  var unitX = new Vector3(1, 0, 0);\n  var unitY = new Vector3(0, 1, 0);\n  var unitZ = new Vector3(0, 0, 1);\n  var tempVector = new Vector3();\n  var dirVector = new Vector3();\n  var alignVector = new Vector3();\n  var tempMatrix = new Matrix4();\n  var identityQuaternion = new Quaternion();\n\n  this.updateMatrixWorld = function () {\n    var space = this.space;\n    this.position.copy(this.worldPosition);\n    if (this.mode === 'scale') space = 'local'; // scale always oriented to local rotation\n\n    unitX.set(1, 0, 0).applyQuaternion(space === 'local' ? this.worldQuaternion : identityQuaternion);\n    unitY.set(0, 1, 0).applyQuaternion(space === 'local' ? this.worldQuaternion : identityQuaternion);\n    unitZ.set(0, 0, 1).applyQuaternion(space === 'local' ? this.worldQuaternion : identityQuaternion); // Align the plane for current transform mode, axis and space.\n\n    alignVector.copy(unitY);\n\n    switch (this.mode) {\n      case 'translate':\n      case 'scale':\n        switch (this.axis) {\n          case 'X':\n            alignVector.copy(this.eye).cross(unitX);\n            dirVector.copy(unitX).cross(alignVector);\n            break;\n\n          case 'Y':\n            alignVector.copy(this.eye).cross(unitY);\n            dirVector.copy(unitY).cross(alignVector);\n            break;\n\n          case 'Z':\n            alignVector.copy(this.eye).cross(unitZ);\n            dirVector.copy(unitZ).cross(alignVector);\n            break;\n\n          case 'XY':\n            dirVector.copy(unitZ);\n            break;\n\n          case 'YZ':\n            dirVector.copy(unitX);\n            break;\n\n          case 'XZ':\n            alignVector.copy(unitZ);\n            dirVector.copy(unitY);\n            break;\n\n          case 'XYZ':\n          case 'E':\n            dirVector.set(0, 0, 0);\n            break;\n        }\n\n        break;\n\n      case 'rotate':\n      default:\n        // special case for rotate\n        dirVector.set(0, 0, 0);\n    }\n\n    if (dirVector.length() === 0) {\n      // If in rotate mode, make the plane parallel to camera\n      this.quaternion.copy(this.cameraQuaternion);\n    } else {\n      tempMatrix.lookAt(tempVector.set(0, 0, 0), dirVector, alignVector);\n      this.quaternion.setFromRotationMatrix(tempMatrix);\n    }\n\n    Object3D.prototype.updateMatrixWorld.call(this);\n  };\n};\n\nTransformControlsPlane.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: TransformControlsPlane,\n  isTransformControlsPlane: true\n});\nexport { TransformControls, TransformControlsGizmo, TransformControlsPlane };","map":null,"metadata":{},"sourceType":"module"}