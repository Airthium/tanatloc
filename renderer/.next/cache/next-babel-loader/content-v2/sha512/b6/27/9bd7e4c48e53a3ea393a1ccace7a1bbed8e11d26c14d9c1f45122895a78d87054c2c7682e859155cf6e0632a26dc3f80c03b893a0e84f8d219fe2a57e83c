{"ast":null,"code":"import _Layout from \"antd/lib/layout\";\nimport _Popconfirm from \"antd/lib/popconfirm\";\nimport _Button from \"antd/lib/button\";\nimport _Card from \"antd/lib/card\";\nimport _Spin from \"antd/lib/spin\";\nimport _Alert from \"antd/lib/alert\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport _Collapse from \"antd/lib/collapse\";\nimport _Space from \"antd/lib/space\";\nimport _Upload from \"antd/lib/upload\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport _Typography from \"antd/lib/typography\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useState, useEffect } from 'react';\nimport { DeleteOutlined, DownloadOutlined, LoadingOutlined, PlusOutlined, QuestionCircleOutlined } from '@ant-design/icons';\nimport { Error } from '../../../assets/notification';\nimport SimulationAPI from '../../../../../src/api/simulation';\nimport FileAPI from '../../../../../src/api/file';\n/**\n * Errors simulation/geometry\n * @memberof module:renderer/components/project/simulation\n */\n\nconst errors = {\n  updateError: 'Unable to update the simulation',\n  downloadError: 'Unable to download the file',\n  UNABLE_TO_LOAD: 'Unable to load geometry'\n};\n/**\n * Geometry\n * @memberof module:renderer/components/project/simulation\n * @param {Object} props Props\n */\n\nconst Geometry = ({\n  project,\n  simulation,\n  part\n}) => {\n  var _part$solids, _part$faces, _part$edges;\n\n  // State\n  const {\n    0: upload,\n    1: setUpload\n  } = useState(false);\n  const {\n    0: loading,\n    1: setLoading\n  } = useState(false);\n  const {\n    0: currentFile,\n    1: setCurrentFile\n  } = useState(); // Data\n\n  const [, {\n    mutateOneSimulation\n  }] = SimulationAPI.useSimulations(project === null || project === void 0 ? void 0 : project.simulations); // Effect\n\n  useEffect(() => {\n    const file = simulation === null || simulation === void 0 ? void 0 : simulation.scheme.configuration.geometry.file;\n    setCurrentFile(file);\n\n    if (file) {\n      setUpload(false);\n    } else {\n      setUpload(true);\n    }\n  }, [simulation]);\n  /**\n   * Upload check\n   * @param {Object} file File\n   */\n\n  const beforeUpload = file => {\n    const goodFormat = file.name.toLowerCase().includes('.stp') || file.name.toLowerCase().includes('.step') || file.name.toLowerCase().includes('.dxf');\n    return goodFormat;\n  };\n  /**\n   * On upload\n   * @param {object} info Info\n   */\n\n\n  const onChange = async info => {\n    if (info.file.status === 'uploading') setLoading(true);\n\n    if (info.file.status === 'done') {\n      const buffer = await getFile(info.file.originFileObj); // Diff scheme\n\n      const diff = {\n        file: {\n          name: info.file.name,\n          uid: info.file.uid,\n          buffer: Buffer.from(buffer)\n        },\n        done: true\n      };\n\n      try {\n        // Update simulation\n        await SimulationAPI.update({\n          id: simulation.id\n        }, [{\n          key: 'scheme',\n          type: 'json',\n          method: 'diff',\n          path: ['configuration', 'geometry'],\n          value: diff\n        }]); // Mutate simulation\n\n        mutateOneSimulation(_objectSpread({}, simulation), true);\n      } catch (err) {\n        Error(errors.updateError, err);\n      } finally {\n        setLoading(false);\n      }\n    }\n  };\n  /**\n   * Get file\n   * @param {Object} file File\n   */\n\n\n  const getFile = async file => {\n    const reader = new FileReader();\n    const buffer = await new Promise(resolve => {\n      reader.addEventListener('load', () => {\n        resolve(reader.result);\n      });\n      reader.readAsArrayBuffer(file);\n    });\n    return buffer;\n  };\n  /**\n   * On delete\n   */\n\n\n  const onDelete = async () => {\n    // Diff scheme\n    const diff = {\n      file: 'remove',\n      done: false\n    };\n\n    try {\n      // Update simulation\n      await SimulationAPI.update({\n        id: simulation.id\n      }, [{\n        key: 'scheme',\n        type: 'json',\n        method: 'diff',\n        path: ['configuration', 'geometry'],\n        value: diff\n      }]); // Mutate\n\n      mutateOneSimulation(_objectSpread(_objectSpread({}, simulation), {}, {\n        scheme: _objectSpread(_objectSpread({}, simulation.scheme), {}, {\n          configuration: _objectSpread(_objectSpread({}, simulation.scheme.configuration), {}, {\n            geometry: _objectSpread(_objectSpread({}, simulation.scheme.configuration.geometry), {}, {\n              file: undefined,\n              done: false\n            })\n          })\n        })\n      }));\n    } catch (err) {\n      Error(errors.updateError, err);\n    }\n  };\n\n  const onDownload = async () => {\n    const file = {\n      origin: simulation.scheme.configuration.geometry.file.origin,\n      originPath: simulation.scheme.configuration.geometry.file.originPath\n    };\n\n    try {\n      const content = await FileAPI.get({\n        id: simulation.id\n      }, file);\n      const data = new File([Buffer.from(content.buffer).toString()], file.origin);\n      const url = window.URL.createObjectURL(data);\n      const link = document.createElement('a');\n      link.href = url;\n      link.setAttribute('download', file.origin);\n      link.click();\n      link.remove();\n    } catch (err) {\n      Error(errors.downloadError, err);\n    }\n  };\n\n  useEffect(() => {\n    var _window$MathJax;\n\n    (_window$MathJax = window.MathJax) === null || _window$MathJax === void 0 ? void 0 : _window$MathJax.typeset();\n  }, []);\n  /**\n   * Render\n   */\n\n  return /*#__PURE__*/_jsx(_Layout, {\n    children: /*#__PURE__*/_jsx(_Layout.Content, {\n      children: upload ? /*#__PURE__*/_jsxs(_Space, {\n        direction: \"vertical\",\n        children: [/*#__PURE__*/_jsx(_Typography.Text, {\n          children: /*#__PURE__*/_jsx(\"b\", {\n            children: \"Upload a geometry\"\n          })\n        }), /*#__PURE__*/_jsx(_Typography.Text, {\n          children: \"STEP (3D) of DXF (2D) file\"\n        }), /*#__PURE__*/_jsx(_Upload, {\n          accept: \".stp,.step,.dxf\",\n          showUploadList: false,\n          listType: \"picture-card\",\n          beforeUpload: beforeUpload,\n          onChange: onChange,\n          children: /*#__PURE__*/_jsxs(\"div\", {\n            children: [loading ? /*#__PURE__*/_jsx(LoadingOutlined, {}) : /*#__PURE__*/_jsx(PlusOutlined, {}), /*#__PURE__*/_jsx(\"div\", {\n              style: {\n                marginTop: 8\n              },\n              children: \"Upload\"\n            })]\n          })\n        })]\n      }) : /*#__PURE__*/_jsxs(_Fragment, {\n        children: [/*#__PURE__*/_jsx(_Card, {\n          title: \"Informations\",\n          children: /*#__PURE__*/_jsxs(_Space, {\n            direction: \"vertical\",\n            children: [/*#__PURE__*/_jsxs(_Typography.Text, {\n              children: [/*#__PURE__*/_jsx(\"b\", {\n                children: \"File:\"\n              }), \" \", currentFile === null || currentFile === void 0 ? void 0 : currentFile.name, ' ']\n            }), /*#__PURE__*/_jsxs(_Typography.Text, {\n              children: [/*#__PURE__*/_jsx(\"b\", {\n                children: \"Unit:\"\n              }), \" \\\\(m\\\\)\"]\n            }), part ? part.error ? /*#__PURE__*/_jsx(_Alert, {\n              message: \"Error\",\n              description: /*#__PURE__*/_jsxs(_Fragment, {\n                children: [errors.UNABLE_TO_LOAD, /*#__PURE__*/_jsx(_Collapse, {\n                  ghost: true,\n                  children: /*#__PURE__*/_jsx(_Collapse.Panel, {\n                    header: \"Error\",\n                    children: part.message\n                  })\n                })]\n              }),\n              type: \"error\"\n            }) : /*#__PURE__*/_jsxs(_Fragment, {\n              children: [part.solids && /*#__PURE__*/_jsxs(_Typography.Text, {\n                children: [/*#__PURE__*/_jsx(\"b\", {\n                  children: \"Number of solids:\"\n                }), \" \", (_part$solids = part.solids) === null || _part$solids === void 0 ? void 0 : _part$solids.length]\n              }), part.faces && /*#__PURE__*/_jsxs(_Typography.Text, {\n                children: [/*#__PURE__*/_jsx(\"b\", {\n                  children: \"Number of faces:\"\n                }), \" \", (_part$faces = part.faces) === null || _part$faces === void 0 ? void 0 : _part$faces.length]\n              }), part.edges && /*#__PURE__*/_jsxs(_Typography.Text, {\n                children: [/*#__PURE__*/_jsx(\"b\", {\n                  children: \"Number of edges:\"\n                }), \" \", (_part$edges = part.edges) === null || _part$edges === void 0 ? void 0 : _part$edges.length]\n              })]\n            }) : /*#__PURE__*/_jsx(_Spin, {})]\n          })\n        }), /*#__PURE__*/_jsxs(_Space, {\n          style: {\n            marginTop: '10px'\n          },\n          children: [/*#__PURE__*/_jsx(_Button, {\n            icon: /*#__PURE__*/_jsx(DownloadOutlined, {}),\n            onClick: onDownload\n          }), /*#__PURE__*/_jsx(_Popconfirm, {\n            title: \"Are you sure\",\n            icon: /*#__PURE__*/_jsx(QuestionCircleOutlined, {\n              style: {\n                color: 'red'\n              }\n            }),\n            onConfirm: onDelete,\n            children: /*#__PURE__*/_jsx(_Button, {\n              type: \"danger\",\n              icon: /*#__PURE__*/_jsx(DeleteOutlined, {})\n            })\n          })]\n        })]\n      })\n    })\n  });\n};\n\nexport default Geometry;","map":null,"metadata":{},"sourceType":"module"}