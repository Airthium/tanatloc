// This function helps to determine:

// 1- Connectivity matrix Conne: for each dof at the contact area gives the triangle ID (1,...,Th.nbe) connected to the dof
// 2- Connectivity matrix vector Connevec: for each dof at the contact area gives the number of triangles connected to the dof (1 or 2)
// 3- triangle dof tridof (3 dof because 3 vertices and corresponds to x dof)
// 4- Connectivity matrix Conorm: for each general dof => the triangle ID (1,...,Th.nbe) connected to the dof
// 5- Connectivity matrix vector Conormvec: for each general dof gives the number of triangles connected to the dof (1 or 2)
<%# TODO review with Houssam -%>
func int connectivity(mesh3 &ThFu, mesh3 &Th,
    int[int, int] &Conne1, int[int] &Connevec1, int[int] &tri1, int[int] &tridof1,
    int[int] &tridof2, int[int] &vertdof2,
    real[int] &DofsOnCont1, int[int] &triid1, int &ntri1,
    int[int, int] &Conorm2, int[int] &Conormvec2
) {
    
    meshN Th1 = Th;
    meshN Th2 = ThFu;
    ntri1 = 0; // Triangle number belonging to the contact surface
    tri1 = - 1; // For each boundary element "ni" in contact 1 gives the ID of the triangle
    
    // First body
    for (int ni = 0; ni < Th1.nbe; ni++) {
        // Loop on the boundary elements of the body 1
        int tetr = Th1.be(ni).Element; // Tetrahedron number
        int dof1x = WhD(tetr, 0); // x dof of the first node
        int dof2x = WhD(tetr, 1); // x dof of the second node
        int dof3x = WhD(tetr, 2); // x dof of the third node
        int dof4x = WhD(tetr, 3); // x dof of the fourth node
        // //
        bool dofin1 = false; // First vertice in the contact area 1?
        bool dofin2 = false; // Second vertice in the contact area 1?
        bool dofin3 = false; // Third vertice in the contact area 1?
        bool dofin4 = false; // Fourth vertice in the contact area 1?
        if (DofsOnCont1[dof1x]) {
            dofin1 = true; // The first vertice belongs to the contact area 1
        }
        if (DofsOnCont1[dof2x]) {
            dofin2 = true; // The second vertice belongs to the contact area 1
        }
        if (DofsOnCont1[dof3x]) {
            dofin3 = true; // The third vertice belongs to the contact area 1
        }
        if (DofsOnCont1[dof4x]) {
            dofin4 = true; // The fourth vertice belongs to the contact area 1
        }
        
        real[int] v1 = [Th1.be(ni)[0].x, Th1.be(ni)[0].y, Th1.be(ni)[0].z]; // Coord of the first vertex of the bound_ele ni
        real[int] v2 = [Th1.be(ni)[1].x, Th1.be(ni)[1].y, Th1.be(ni)[1].z]; // Coord of the second vertex of the bound_ele ni
        real[int] v3 = [Th1.be(ni)[2].x, Th1.be(ni)[2].y, Th1.be(ni)[2].z]; // Coord of the third vertex of the bound_ele ni
        
        real[int] vtetr1 = [Th1[tetr][0].x, Th1[tetr][0].y, Th1[tetr][0].z]; // Coord of the vertex 0 of the Tetrahedron tetr
        real[int] vtetr2 = [Th1[tetr][1].x, Th1[tetr][1].y, Th1[tetr][1].z]; // Coord of the vertex 1 of the Tetrahedron tetr
        real[int] vtetr3 = [Th1[tetr][2].x, Th1[tetr][2].y, Th1[tetr][2].z]; // Coord of the vertex 2 of the Tetrahedron tetr
        real[int] vtetr4 = [Th1[tetr][3].x, Th1[tetr][3].y, Th1[tetr][3].z]; // Coord of the vertex 3 of the Tetrahedron tetr
        
        bool ver1bord, ver2bord, ver3bord, ver4bord; // Vertex belongs to the bord ni ?
        
        if (((v1[0] == vtetr1[0]) && (v1[1] == vtetr1[1]) && (v1[2] == vtetr1[2])) || ((v2[0] == vtetr1[0]) && (v2[1] == vtetr1[1]) && (v2[2] == vtetr1[2])) || ((v3[0] == vtetr1[0]) && (v3[1] == vtetr1[1]) && (v3[2] == vtetr1[2]))) {
            ver1bord = true; // Vertex 0 belongs to the bord ni
        } else {
            ver1bord = false;
        }
        
        if (((v1[0] == vtetr2[0]) && (v1[1] == vtetr2[1]) && (v1[2] == vtetr2[2])) || ((v2[0] == vtetr2[0]) && (v2[1] == vtetr2[1]) && (v2[2] == vtetr2[2])) || ((v3[0] == vtetr2[0]) && (v3[1] == vtetr2[1]) && (v3[2] == vtetr2[2]))) {
            ver2bord = true; // Vertex 1 belongs to the bord ni
        } else {
            ver2bord = false;
        }
        
        if (((v1[0] == vtetr3[0]) && (v1[1] == vtetr3[1]) && (v1[2] == vtetr3[2])) || ((v2[0] == vtetr3[0]) && (v2[1] == vtetr3[1]) && (v2[2] == vtetr3[2])) || ((v3[0] == vtetr3[0]) && (v3[1] == vtetr3[1]) && (v3[2] == vtetr3[2]))) {
            ver3bord = true; // Vertex 2 belongs to the bord ni
        } else {
            ver3bord = false;
        }
        
        if (((v1[0] == vtetr4[0]) && (v1[1] == vtetr4[1]) && (v1[2] == vtetr4[2])) || ((v2[0] == vtetr4[0]) && (v2[1] == vtetr4[1]) && (v2[2] == vtetr4[2])) || ((v3[0] == vtetr4[0]) && (v3[1] == vtetr4[1]) && (v3[2] == vtetr4[2]))) {
            ver4bord = true; // Vertex 3 belongs to the bord ni
        } else {
            ver4bord = false;
        }
        
        if (ver1bord && ver2bord && ver3bord) {
            // the three vertices belong to the border (think about the corner)
            tridof1[3 * ni] = dof1x;
            tridof1[3 * ni + 1] = dof2x;
            tridof1[3 * ni + 2] = dof3x;
            
            if (dofin1 && dofin2 && dofin3) {
                tri1[ni] = ntri1;
                int pl = Connevec1[dof1x];
                Conne1(dof1x, pl) = ni;
                Connevec1[dof1x] += 1;
                pl = Connevec1[dof2x];
                Conne1(dof2x, pl) = ni;
                Connevec1[dof2x] += 1;
                pl = Connevec1[dof3x];
                Conne1(dof3x, pl) = ni;
                Connevec1[dof3x] += 1;
                triid1[ntri1] = ni;
                ntri1 += 1;
            }
        }
        if (ver1bord && ver2bord && ver4bord) {
            // the three vertices belong to the border (think about the corner)
            tridof1[3 * ni] = dof1x;
            tridof1[3 * ni + 1] = dof2x;
            tridof1[3 * ni + 2] = dof4x;
            
            if (dofin1 && dofin2 && dofin4) {
                tri1[ni] = ntri1;
                int pl = Connevec1[dof1x];
                Conne1(dof1x, pl) = ni;
                Connevec1[dof1x] += 1;
                pl = Connevec1[dof2x];
                Conne1(dof2x, pl) = ni;
                Connevec1[dof2x] += 1;
                pl = Connevec1[dof4x];
                Conne1(dof4x, pl) = ni;
                Connevec1[dof4x] += 1;
                triid1[ntri1] = ni;
                ntri1 += 1;
            }
        }
        if (ver1bord && ver3bord && ver4bord) {
            // the three vertices belong to the border (think about the corner)
            tridof1[3 * ni] = dof1x;
            tridof1[3 * ni + 1] = dof3x;
            tridof1[3 * ni + 2] = dof4x;
            
            if (dofin1 && dofin3 && dofin4) {
                tri1[ni] = ntri1;
                int pl = Connevec1[dof1x];
                Conne1(dof1x, pl) = ni;
                Connevec1[dof1x] += 1;
                pl = Connevec1[dof3x];
                Conne1(dof3x, pl) = ni;
                Connevec1[dof3x] += 1;
                pl = Connevec1[dof4x];
                Conne1(dof4x, pl) = ni;
                Connevec1[dof4x] += 1;
                triid1[ntri1] = ni;
                ntri1 += 1;
            }
        }
        if (ver2bord && ver3bord && ver4bord) {
            // the three vertices belong to the border (think about the corner)
            tridof1[3 * ni] = dof2x;
            tridof1[3 * ni + 1] = dof3x;
            tridof1[3 * ni + 2] = dof4x;
            
            if (dofin2 && dofin3 && dofin4) {
                tri1[ni] = ntri1;
                int pl = Connevec1[dof2x];
                Conne1(dof2x, pl) = ni;
                Connevec1[dof2x] += 1;
                pl = Connevec1[dof3x];
                Conne1(dof3x, pl) = ni;
                Connevec1[dof3x] += 1;
                pl = Connevec1[dof4x];
                Conne1(dof4x, pl) = ni;
                Connevec1[dof4x] += 1;
                triid1[ntri1] = ni;
                ntri1 += 1;
            }
        }
    }
    
    // Second Body
    for (int ni = 0; ni < Th2.nbe; ni++) {
        // Loop on the boundary elements of the body 2
        int tetr = Th2.be(ni).Element; // Tetrahedron number
        int dof1x = WhF(tetr, 0); // x dof of the first node
        int dof2x = WhF(tetr, 1); // x dof of the second node
        int dof3x = WhF(tetr, 2); // x dof of the third node
        int dof4x = WhF(tetr, 3); // x dof of the fourth node
        
        real[int] v1 = [Th2.be(ni)[0].x, Th2.be(ni)[0].y, Th2.be(ni)[0].z]; // Coord of the first vertex of the bound_ele ni
        real[int] v2 = [Th2.be(ni)[1].x, Th2.be(ni)[1].y, Th2.be(ni)[1].z]; // Coord of the second vertex of the bound_ele ni
        real[int] v3 = [Th2.be(ni)[2].x, Th2.be(ni)[2].y, Th2.be(ni)[2].z]; // Coord of the third vertex of the bound_ele ni
        
        real[int] vtetr1 = [Th2[tetr][0].x, Th2[tetr][0].y, Th2[tetr][0].z]; // Coord of the vertex 0 of the Tetrahedron tetr
        real[int] vtetr2 = [Th2[tetr][1].x, Th2[tetr][1].y, Th2[tetr][1].z]; // Coord of the vertex 1 of the Tetrahedron tetr
        real[int] vtetr3 = [Th2[tetr][2].x, Th2[tetr][2].y, Th2[tetr][2].z]; // Coord of the vertex 2 of the Tetrahedron tetr
        real[int] vtetr4 = [Th2[tetr][3].x, Th2[tetr][3].y, Th2[tetr][3].z]; // Coord of the vertex 3 of the Tetrahedron tetr
        
        bool ver1bord, ver2bord, ver3bord, ver4bord; // Vertex belongs to the bord ni ?
        
        if (((v1[0] == vtetr1[0]) && (v1[1] == vtetr1[1]) && (v1[2] == vtetr1[2])) || ((v2[0] == vtetr1[0]) && (v2[1] == vtetr1[1]) && (v2[2] == vtetr1[2])) || ((v3[0] == vtetr1[0]) && (v3[1] == vtetr1[1]) && (v3[2] == vtetr1[2]))) {
            ver1bord = true; // Vertex 0 belongs to the bord ni
        } else {
            ver1bord = false;
        }
        
        if (((v1[0] == vtetr2[0]) && (v1[1] == vtetr2[1]) && (v1[2] == vtetr2[2])) || ((v2[0] == vtetr2[0]) && (v2[1] == vtetr2[1]) && (v2[2] == vtetr2[2])) || ((v3[0] == vtetr2[0]) && (v3[1] == vtetr2[1]) && (v3[2] == vtetr2[2]))) {
            ver2bord = true; // Vertex 1 belongs to the bord ni
        } else {
            ver2bord = false;
        }
        
        if (((v1[0] == vtetr3[0]) && (v1[1] == vtetr3[1]) && (v1[2] == vtetr3[2])) || ((v2[0] == vtetr3[0]) && (v2[1] == vtetr3[1]) && (v2[2] == vtetr3[2])) || ((v3[0] == vtetr3[0]) && (v3[1] == vtetr3[1]) && (v3[2] == vtetr3[2]))) {
            ver3bord = true; // Vertex 2 belongs to the bord ni
        } else {
            ver3bord = false;
        }
        
        if (((v1[0] == vtetr4[0]) && (v1[1] == vtetr4[1]) && (v1[2] == vtetr4[2])) || ((v2[0] == vtetr4[0]) && (v2[1] == vtetr4[1]) && (v2[2] == vtetr4[2])) || ((v3[0] == vtetr4[0]) && (v3[1] == vtetr4[1]) && (v3[2] == vtetr4[2]))) {
            ver4bord = true; // Vertex 3 belongs to the bord ni
        } else {
            ver4bord = false;
        }
        
        if (ver1bord && ver2bord && ver3bord) {
            // the three vertices belong to the border (think about the corner)
            tridof2[3 * ni] = dof1x;
            tridof2[3 * ni + 1] = dof2x;
            tridof2[3 * ni + 2] = dof3x;
            vertdof2[ni] = dof4x; // dof of the thetraedron vertice that does not belonging to the contact area
            int pln = Conormvec2[dof1x];
            Conorm2(dof1x, pln) = ni;
            Conormvec2[dof1x] += 1;
            pln = Conormvec2[dof2x];
            Conorm2(dof2x, pln) = ni;
            Conormvec2[dof2x] += 1;
            pln = Conormvec2[dof3x];
            Conorm2(dof3x, pln) = ni;
            Conormvec2[dof3x] += 1;
        }
        if (ver1bord && ver2bord && ver4bord) {
            // the three vertices belong to the border (think about the corner)
            tridof2[3 * ni] = dof1x;
            tridof2[3 * ni + 1] = dof2x;
            tridof2[3 * ni + 2] = dof4x;
            vertdof2[ni] = dof3x; // dof of the thetraedron vertice that does not belonging to the contact area
            int pln = Conormvec2[dof1x];
            Conorm2(dof1x, pln) = ni;
            Conormvec2[dof1x] += 1;
            pln = Conormvec2[dof2x];
            Conorm2(dof2x, pln) = ni;
            Conormvec2[dof2x] += 1;
            pln = Conormvec2[dof4x];
            Conorm2(dof4x, pln) = ni;
            Conormvec2[dof4x] += 1;
        }
        if (ver1bord && ver3bord && ver4bord) {
            // the three vertices belong to the border (think about the corner)
            tridof2[3 * ni] = dof1x;
            tridof2[3 * ni + 1] = dof3x;
            tridof2[3 * ni + 2] = dof4x;
            vertdof2[ni] = dof2x; // dof of the thetraedron vertice that does not belonging to the contact area
            int pln = Conormvec2[dof1x];
            Conorm2(dof1x, pln) = ni;
            Conormvec2[dof1x] += 1;
            pln = Conormvec2[dof3x];
            Conorm2(dof3x, pln) = ni;
            Conormvec2[dof3x] += 1;
            pln = Conormvec2[dof4x];
            Conorm2(dof4x, pln) = ni;
            Conormvec2[dof4x] += 1;
        }
        if (ver2bord && ver3bord && ver4bord) {
            // the three vertices belong to the border (think about the corner)
            tridof2[3 * ni] = dof2x;
            tridof2[3 * ni + 1] = dof3x;
            tridof2[3 * ni + 2] = dof4x;
            vertdof2[ni] = dof1x; // dof of the thetraedron vertice that does not belonging to the contact area
            int pln = Conormvec2[dof2x];
            Conorm2(dof2x, pln) = ni;
            Conormvec2[dof2x] += 1;
            pln = Conormvec2[dof3x];
            Conorm2(dof3x, pln) = ni;
            Conormvec2[dof3x] += 1;
            pln = Conormvec2[dof4x];
            Conorm2(dof4x, pln) = ni;
            Conormvec2[dof4x] += 1;
        }
        
    }
    
    return 0;
}