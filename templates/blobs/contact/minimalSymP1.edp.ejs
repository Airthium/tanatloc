// xxx is the array of the points to be projected
// ABC is the array of the current coordinates of the second contact area nodes
// Projection of a point (xp,yp) to the segments of the second body

<% if (locals.dimension !== 2){ -%>
// vector product
func real[int] vectorProduct(real[int] &v1, real[int] &v2) {
    // Vector product
    real[int] product(3);
    product[0] = v1[1] * v2[2] - v1[2] * v2[1];
    product[1] = v1[2] * v2[0] - v1[0] * v2[2];
    product[2] = v1[0] * v2[1] - v1[1] * v2[0];
    return product;
}

// vector product (normalized)
func real[int] vectorProductNormalized(real[int] &v1, real[int] &v2) {
    // Normalized Vector product
    real[int] product(3);
    product[0] = v1[1] * v2[2] - v1[2] * v2[1];
    product[1] = v1[2] * v2[0] - v1[0] * v2[2];
    product[2] = v1[0] * v2[1] - v1[1] * v2[0];
    product = product / ((product[0]^2 + product[1]^2 + product[2]^2)^0.5); // normalized
    return product;
}
<% } -%>

// Minimal projection
// ThFu Fundation mesh
// xxx Position of points
// XYZ Fundation mesh positions
// position Store position of the closest element of the fundation
// elementDof Store DOF of the closest element of the fundation
func real[int] minimalProjection(meshN ThFu, real[int] &xxx, real[int] &XYZ, int[int] &position, int[int] &elementDof) {
    // Number of points to be projected
    int nPoints = xxx.n / <%- locals.dimension -%>;
    // eta parameters of the projected points of the integration points
    real[int] etaParameters((<%- locals.dimension -%> - 1) * nPoints);
    // The border segment number
    int nu;
    R3 ph;
    
    // The border of ThFu
    meshN1 Lh = extract(ThFu);
    
    for (int i = 0; i < nPoints; i++) {
        // Loop on the integration points
        // The abssica of the integration point
        x = xxx[<%- locals.dimension -%> * i];
        // The ordinate of the integration point
        y = xxx[<%- locals.dimension -%> * i + 1];
        z = 0;
<% if (locals.dimension !== 2){ -%>
        z = xxx[3 * i + 2]; // 3D case
<% } -%>
        
        // Projection of the integration point
        R3 proj = projection(Lh, nu = nu, Phat = ph);
        // Abssica of the projection of the integration point
        real xproj = proj.x;
        // Ordinate of the projection of the integration point
        real yproj = proj.y;
<% if (locals.dimension !== 2){ -%>
        real zproj = proj.z; // 3D case
<% } -%>
        
        position[i] = nu;
        
        // dof x of the first vertice of the element
        int dofx0 = elementDof[<%- locals.dimension -%> * nu];
        // dof x of the second vertice of the element
        int dofx1 = elementDof[<%- locals.dimension -%> * nu + 1];
<% if (locals.dimension !== 2){ -%>
        // dof x of the third vertice of element
        int dofx2 = elementDof[<%- locals.dimension -%> * nu + 2];
<% } -%>
        
        // x of the first vertice of the element
        real xA = XYZ[dofx0];
        // y of the first vertice of the element
        real yA = XYZ[dofx0 + 1];
<% if (dimension !== 2){ -%>
        // z of the first vertice of the element
        real zA = XYZ[dofx0 + 2];
<% } -%>
        
        // x of the second vertice of the element
        real xB = XYZ[dofx1];
        // y of the second vertice of the element
        real yB = XYZ[dofx1 + 1];
<% if (dimension !== 2){ -%>
        // z of the second vertice of the element
        real zB = XYZ[dofx1 + 2];
        
        // x of the second vertice of the element
        real xC = XYZ[dofx2];
        // y of the second vertice of the element
        real yC = XYZ[dofx2 + 1];
        // z of the second vertice of the element
        real zC = XYZ[dofx2 + 2];
<% } -%>
        
<% if (dimension == 2) { -%>
        real dPA = sqrt((xproj - xA)^2 + (yproj - yA)^2);
        real dAB = sqrt((xB - xA)^2 + (yB - yA)^2);
        etaParameters[i] = dPA / dAB;
<% } else { -%>
        real SABC, SPAC, SPAB;
        real[int] AB(3), AC(3), BC(3), PA(3), PC(3), PB(3), provec(3);
        AB = [xB - xA, yB - yA, zB - zA];
        AC = [xC - xA, yC - yA, zC - zA];
        
        PA = [xA - xproj, yA - yproj, zA - zproj];
        PC = [xC - xproj, yC - yproj, zC - zproj];
        PB = [xB - xproj, yB - yproj, zB - zproj];
        
        // Vectorial product in order to compute the area of a triangle
        provec = vectorProduct(AB, AC);
        // The surface of the triangle
        SABC = 0.5 * (provec[0]^2 + provec[1]^2 + provec[2]^2)^0.5;
        
        // Vectorial product in order to compute the area of a triangle
        provec = vectorProduct(PA, PC);
        // The surface of the triangle
        SPAC = 0.5 * (provec[0]^2 + provec[1]^2 + provec[2]^2)^0.5;
        
        // Vectorial product in order to compute the area of a triangle
        provec = vectorProduct(PA, PB);
        // The surface of the triangle
        SPAB = 0.5 * (provec[0]^2 + provec[1]^2 + provec[2]^2)^0.5;
        
        // First parameter (surface of triangle PAC / surface of triangle ABC)
        etaParameters[2 * i] = SPAC / SABC;
        // Second parameter (surface of triangle PAB / surface of triangle ABC)
        etaParameters[2 * i + 1] = SPAB / SABC;
<% } -%>
    }

    return etaParameters;
}