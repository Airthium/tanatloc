SetFactory("OpenCASCADE");
V() = ShapeFromFile("<%= geometry %>");

Mesh.Optimize = 1;

// Make interface unique
//For i In {0: #V[]-1}
//	V() = BooleanFragments { Volume{V[i]}; Delete; } { Volume{V[]}; Delete; };
//EndFor
// End make interface unique

// Compute minimal distance on the bounding box
// this is used for automatic size of the mesh
lmin = 0;
lmax = 0;
For i In {0:#V[]-1}
	bb() = BoundingBox Volume{V[i]};

	xmin = bb[0];
	xmax = bb[3];
	ymin = bb[1];
	ymax = bb[4];
	zmin = bb[2];
	zmax = bb[5];

	lx = xmax - xmin;
	ly = ymax - ymin;
	lz = zmax - zmin;

	llmin = (lx < ly) ? lx : ly;
	llmin = (llmin < lz) ? llmin : lz;
	llmax = (lx > ly) ? lx : ly;
	llmax = (llmax > lz) ? llmax : lz;

	If (i == 0)
		lmin = llmin;
		lmax = llmax;
	Else
		lmin = (lmin < llmin) ? lmin : llmin;
		lmax = (lmax > llmax) ? lmax : llmax;
	EndIf
EndFor
lmin = lmin / 10.;
Printf("Minimal distance on the bounding box = %f", lmin);
Printf("Maximal distance on the bounding box = %f", lmax);

// Global size
<% if (size === 'manual') { // Manual size -%>
globalMinSize = <%= values[0] %>;
globalMaxSize = <%= values[1] %>;
<% } else { // Auto size -%>
<% if (fineness === 'verycoarse') { -%>
globalMinSize = lmax/10. + (lmin/10. - lmax/10.)*0.;
globalMaxSize = lmax/2. + (lmin/2. - lmax/2.)*0.;
<% } else if (fineness === 'coarse') { -%>
globalMinSize = lmax/10. + (lmin/10. - lmax/10.)*0.25;
globalMaxSize = lmax/2. + (lmin/2. - lmax/2.)*0.25;
<% } else if (fineness === 'fine') { -%>
globalMinSize = lmax/10. + (lmin/10. - lmax/10.)*0.75;
globalMaxSize = lmax/2. + (lmin/2. - lmax/2.)*0.75;
<% } else if (fineness === 'veryfine') { -%>
globalMinSize = lmax/10. + (lmin/10. - lmax/10.)*1.;
globalMaxSize = lmax/2. + (lmin/2. - lmax/2.)*1.;
<% } else { -%>
globalMinSize = lmax/10. + (lmin/10. - lmax/10.)*0.5;
globalMaxSize = lmax/2. + (lmin/2. - lmax/2.)*0.5;
<% } -%>
<% } -%>
// End global size

// Physical labels for each volumes & surfaces
SLabel = 1;
VLabel = 1;
For i In {0:#V[]-1}
	Physical Volume (VLabel) = { V[i] };
	VLabel = VLabel + 1;

	S() = Boundary { Volume{V[i]}; };

	For j In {0:#S[]-1}
		Physical Surface (SLabel) = { S[j] };
		SLabel = SLabel + 1;
	EndFor

	P() = PointsOf { Surface{S[]}; };
	Characteristic Length { P[] } = globalMinSize;
EndFor
// End physical labels

// Refinements
<% if (typeof refinements !== 'undefined') { -%>
<% refinements.forEach(refinement => {
	const selected = refinement.selection.selected.map(selected => selected.label)
	if (refinement.selection.type === 'solids') {
-%>
P() = PointsOf { Volume{<%= selected.join('') %>}; };
<% } else { -%>
P() = PointsOf { Surface{<%= selected.join(',') %>}; };
<% } -%>
<% if (refinement.size === 'manual') { // Manual size -%>
localMinSize = <%= refinement.values[0] %>;
localMaxSize = <%= refinement.values[1] %>;
<% } else { -%>
<% if (refinement.fineness === 'verycoarse') { -%>
localMinSize = lmax/10. + (lmin/10. - lmax/10.)*0.;
localMaxSize = lmax/2. + (lmin/2. - lmax/2.)*0.;
<% } else if (refinement.fineness === 'coarse') { -%>
localMinSize = lmax/10. + (lmin/10. - lmax/10.)*0.25;
localMaxSize = lmax/2. + (lmin/2. - lmax/2.)*0.25;
<% } else if (refinement.fineness === 'fine') { -%>
localMinSize = lmax/10. + (lmin/10. - lmax/10.)*0.75;
localMaxSize = lmax/2. + (lmin/2. - lmax/2.)*0.75;
<% } else if (refinement.fineness === 'veryfine') { -%>
localMinSize = lmax/10. + (lmin/10. - lmax/10.)*1.;
localMaxSize = lmax/2. + (lmin/2. - lmax/2.)*1.;
<% } else { -%>
localMinSize = lmax/10. + (lmin/10. - lmax/10.)*0.5;
localMaxSize = lmax/2. + (lmin/2. - lmax/2.)*0.5;
<% } -%>
<% } -%>
Characteristic Length { P[] } = localMinSize;

If (globalMinSize > localMinSize)
	globalMinSize = localMinSize;
EndIf
If (globalMaxSize < localMaxSize)
	globalMaxSize = localMaxSize;
EndIf
<% }) -%>
<% } -%>
// End refinements

Mesh.CharacteristicLengthMin = globalMinSize;
Mesh.CharacteristicLengthMax = globalMaxSize;
