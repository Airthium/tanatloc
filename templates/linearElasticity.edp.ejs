try {
	<%# Headers -%>
	<%- include('/blobs/headers.edp.ejs') -%>

	<%# Dimension -%>
	<%- include('/blobs/dimensioning.edp.ejs', {
		dimension
	}); -%>

	<%# Mesh -%>
	<%
	const mesh = geometry.mesh
	mesh.name = 'Mesh'
	-%>
	<%- include('/blobs/mesh.edp.ejs', {
		dimension,
		mesh
	}); -%>

	<%# Material -%>
	<%- include('/blobs/materials.edp.ejs', {
		materials
	}) -%>

	<%# Finite element space -%>
	<%
	const finiteElementSpace = parameters.finiteElementSpace.children[0]
	finiteElementSpace.name = 'Uh'
	-%>
	<%- include('/blobs/fespace.edp.ejs', {
		mesh,
		finiteElementSpace
	}); -%>

	<%# Finite element function -%>
	<%
	const unknownFunction = dimension === 2 ? '[Ux, Uy]' : '[Ux, Uy, Uz]'
	const testFunction = dimension === 2 ? '[Uhx, Uhy]' : '[Uhx, Uhy, Uhz]'
	-%>
	<%- include('/blobs/fespaceFunction.edp.ejs', {
		finiteElementSpace,
		finiteElementFunction: dimension === 2 ? ['Ux', 'Uy'] :['Ux', 'Uy', 'Uz']
	}); -%>

	<%# Macro -%>
	<%- include('/blobs/macro.edp.ejs', {
		dimension,
		type: ['vectorialDivergence', 'vectorialEpsilon']
	}); -%>

	// Variables
	real Mu = E/(2.*(1.+Nu));
	real Lambda = E*Nu/((1.+ Nu)*(1.-2.*Nu));

	<%# Problem -%>
	<%
	const fixed = boundaryConditions.fixed.values || []
	const displacement = boundaryConditions.displacement.values || []
	const presure = boundaryConditions.presure.values || []
	const rhs = parameters.rightHandSide.children
	const rhsX = rhs[0].value ?? rhs[0].default
	const rhsY = rhs[1].value ?? rhs[1].default
	const rhsZ = rhs[2].value ?? rhs[2].default

	const N = dimension === 2 ? '[N.x, N.y]' : '[N.x, N.y, N.z]'
	-%>
	// Problem
	appendLog("Define the problem...");

	varf vLinearElasticity (<%= unknownFunction -%>, <%= testFunction -%>)
		= intN(Mesh)(
			Lambda * Div(U) * Div(Uh)
			+ 2. * Mu * (
				Epsilon(U)' * Epsilon(Uh)
			)
		)
	<% for (const d of displacement) { -%>
		+ on(<%= d.selected.map(s => s.label).filter(s => s).join() -%>
		<% if (d.values[0].checked) { -%>, Ux=0<% } -%>
		<% if (d.values[1].checked) { -%>, Uy=0<% } -%>
		<% if (dimension !== 2 && d.values[2].checked) { -%>, Uz=0<% } -%>
		)
	<% } -%>
	<% for (const f of fixed) { -%>
		+ on(<%= f.selected.map(s => s.label).filter(s => s).join() -%>, Ux=0, Uy=0<% if (dimension !== 2) { -%> , Uz=0<% } -%>)
	<% } -%>
		;

	varf vLinearElasticityRHS (<%= unknownFunction -%>, <%= testFunction -%>)
		= intN(Mesh)(
	<% if (dimension === 2) { -%>
			Rho * [<%- rhsX -%>, <%- rhsY -%>]' * <%= testFunction %>
	<% } else { -%>
			Rho * [<%- rhsX -%>, <%- rhsY -%>, <%- rhsZ -%>]' * <%= testFunction %>
	<% } -%>
		)
	<% for (const p of presure) { -%>
		- intN1(Mesh, <%= p.selected.map(s => s.label).filter(s => s).join() -%>)(
			(<%- p.values[0].value ?? p.values[0].default -%>) * <%= N -%>' * <%= testFunction -%>
		)
	<% } -%>
	<% for (const d of displacement) { -%>
		+ on(<%= d.selected.map(s => s.label).filter(s => s).join() -%>
		<% if (d.values[0].checked) { -%>, Ux=<%- d.values[0].value ?? d.values[0].default -%><% } -%>
		<% if (d.values[1].checked) { -%>, Uy=<%- d.values[1].value ?? d.values[1].default -%><% } -%>
		<% if (dimension !== 2 && d.values[2].checked) { -%>, Uz=<%- d.values[2].value ?? d.values[2].default -%><% } -%>
		)
	<% } -%>
	<% for (const f of fixed) { -%>
		+ on(<%= f.selected.map(s => s.label).filter(s => s).join() -%>, Ux=0, Uy=0<% if (dimension !== 2) { -%> , Uz=0<% } -%>)
	<% } -%>
		;

	<%# Solver -%>
	<% const solver = parameters.solver.children[0].value ?? parameters.solver.children[0].default -%>
	<%- include('/blobs/solver.edp.ejs', {
		solver
	}) -%>

	<%# Solve -%>
	// Solve
	appendLog("Solve the problem...");

	matrix LinearElasticity = vLinearElasticity(<%= finiteElementSpace.name -%>, <%= finiteElementSpace.name -%>, solver=solver);
	real[int] LinearElasticityRHS = vLinearElasticityRHS(0, <%= finiteElementSpace.name -%>);
	Ux[] = LinearElasticity^-1 * LinearElasticityRHS;

	<%# von Mises stress -%>
	fespace Sh(Mesh, P2);
	Sh epsilon11 = dx(Ux);
	Sh epsilon22 = dy(Uy);
	Sh epsilon33 = <% if (dimension === 2) { -%>0<% } else { -%>dz(Uz)<% } -%>;
	Sh epsilon12 = 0.5*(dy(Ux) + dx(Uy));
	Sh epsilon13 = <% if (dimension === 2) { -%>0<% } else { -%>0.5*(dz(Ux) + dx(Uz))<% } -%>;
	Sh epsilon23 = <% if (dimension === 2) { -%>0<% } else { -%>0.5*(dy(Uz) + dz(Uy))<% } -%>;

	Sh traceEpsilon = epsilon11 + epsilon22 + epsilon33;

	Sh gamma11 = 2.*Mu * epsilon11 + Lambda * traceEpsilon;
	Sh gamma22 = 2.*Mu * epsilon22 + Lambda * traceEpsilon;
	Sh gamma33 = 2.*Mu * epsilon33 + Lambda * traceEpsilon;
	Sh gamma12 = 2.*Mu * epsilon12;
	Sh gamma13 = 2.*Mu * epsilon13;
	Sh gamma23 = 2.*Mu * epsilon23;

	Sh Sigma = sqrt(
		0.5 * ((gamma11 - gamma22)^2 + (gamma22 - gamma33)^2 + (gamma33 - gamma11)^2)
		+ 3.*(gamma12^2 + gamma23^2 + gamma13^2)
	);

	<% if (parameters.meshAdaptation.children[0].value) { -%>
	// Mesh adaptation
	fespace Hh(Mesh, P0);
	Hh h = hTriangle;
	real minh = h[].min;
	real maxh = h[].max;
	int nLoops = <%= parameters.meshAdaptation.children[1].value ?? parameters.meshAdaptation.children[1].default -%>;
	for (int i = 0; i < nLoops; ++i) {
		<% if (dimension === 2) { -%>
		Mesh = adaptmesh(Mesh, Sigma, hmin=minh/5., hmax=maxh);
		<% } else { -%>
		load "mshmet"
		load "mmg"
		real[int] metric = mshmet(Mesh, Sigma, aniso=1, hmin=minh/5., hmax=maxh);
		Mesh = mmg3d(Mesh, metric=metric);
		<% } -%>

		<%= unknownFunction -%> = <%= unknownFunction -%>;

		matrix LinearElasticity = vLinearElasticity(<%= finiteElementSpace.name -%>, <%= finiteElementSpace.name -%>, solver=solver);
		real[int] LinearElasticityRHS = vLinearElasticityRHS(0, <%= finiteElementSpace.name -%>);
		Ux[] = LinearElasticity^-1 * LinearElasticityRHS;
	}
	<% } -%>

	<%# Save -%>
	<%- include('/blobs/save.edp.ejs', {
		solution: {
			path: run.resultPath,
			name: '"Result"',
			mesh: mesh.name,
			sol: [dimension === 2 ? ['Ux', 'Uy', '0'] : ['Ux', 'Uy', 'Uz'], 'Sigma', 'gamma11', 'gamma12', 'gamma13', 'gamma22', 'gamma23', 'gamma33'],
			dataName: run.results.map(r => r.name),
			order: [1, 1, 1, 1, 1, 1, 1, 1]
		}
	}); -%>

	appendLog("End");
} catch(...) {
	appendError("An internal error occurs");
	exit(-1);
}