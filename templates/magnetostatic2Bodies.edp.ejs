try {
    load "ff-Ipopt"
    load "msh3"
    
<%# Headers -%>
<%- helpers.indent(include('/blobs/headers.edp.ejs'), 1) -%>
    
<%# Dimension -%>
<%- helpers.indent(include('/blobs/dimensioning.edp.ejs', {
    dimension
}), 1) -%>
    
<%# Mesh -%>
<%
    const meshes = geometry.meshes
    meshes.forEach((mesh, index) => mesh.name = 'Mesh' + index)
-%>
<% meshes.forEach(mesh => { -%>
<%- helpers.indent(include('/blobs/mesh.edp.ejs', {
        dimension,
        mesh
    }), 1) -%>
<% }) -%>

    // Mesh0 and Mesh1 are the meshes    

<%# Material -%>
<%
    meshes.forEach((mesh, index) => {
-%>
<%- helpers.indent(include('/blobs/materials.edp.ejs', {
    materials,
    geometryIndex: index
}), 1) -%>
<%
    })
-%>
    
    // Material properties Mu0 and Mu1
    
<%# Finite element space -%>
<%
    const finiteElementSpace = parameters.finiteElementSpace.children[0]
-%>
    // First deformable body
<%- helpers.indent(include('/blobs/fespace.edp.ejs', {
    mesh: {name: 'Mesh0'},
    finiteElementSpace: {
        name: 'FE1',
        ...finiteElementSpace
    }
}), 1) -%>
    
    // Second deformable body
<%- helpers.indent(include('/blobs/fespace.edp.ejs', {
    mesh: {name: 'Mesh1'},
    finiteElementSpace: {
        name: 'FE2',
        ...finiteElementSpace
    }
}), 1) -%>
    
<%# Finite element function -%>
// unknown = [Ax1, Ay1, Az1] for the firqst body and [Ax2, Ay2, Az2] for the second one
<%
    const unknownFunction1X = variables[1].value + '1'
    const unknownFunction1Y = variables[2].value + '1'
    const unknownFunction1Z = variables[3].value + '1'
    const unknownFunction1 =
        dimension === 2
            ? '[' + unknownFunction1Z +  ']'
            : '[' + unknownFunction1X + ', ' + unknownFunction1Y + ', ' + unknownFunction1Z + ']'
    const testFunction1X = unknownFunction1X + 'h'
    const testFunction1Y = unknownFunction1Y + 'h'
    const testFunction1Z = unknownFunction1Z + 'h'
    const testFunction1 =
        dimension === 2
            ? '[' + testFunction1Z + ']'
            : '[' + testFunction1X + ', ' + testFunction1Y + ', ' + testFunction1Z + ']'

    const unknownFunction2X = variables[1].value + '2'
    const unknownFunction2Y = variables[2].value + '2'
    const unknownFunction2Z = variables[3].value + '2'
    const unknownFunction2 =
        dimension === 2
            ? '[' + unknownFunction2Z +  ']'
            : '[' + unknownFunction2X + ', ' + unknownFunction2Y + ', ' + unknownFunction2Z + ']'
    const testFunction2X = unknownFunction2X + 'h'
    const testFunction2Y = unknownFunction2Y + 'h'
    const testFunction2Z = unknownFunction2Z + 'h'
    const testFunction2 =
        dimension === 2
            ? '[' + testFunction2Z + ']'
            : '[' + testFunction2X + ', ' + testFunction2Y + ', ' + testFunction2Z + ']'           
-%>

<%# Macro -%>
<%- helpers.indent(include('/blobs/macro.edp.ejs', {
    dimension,
    type: ['Curl', 'Divergence', 'DotNormal']
}), 1) -%>

<%# Problem -%>
<%
    const dirichletProd = boundaryConditions.dirichletProd.values ?? []
    const contactArea = boundaryConditions.contactArea.values ?? []
    const current = parameters.current.children
    const penalty = parameters.penalty.children
    const currentValueX = current[0].value ?? current[0].default
    const currentValueY = current[1].value ?? current[1].default
    const currentValueZ = current[2].value ?? current[2].default
    const N = dimension === 2 ? '[N.x, N.y]' : '[N.x, N.y, N.z]'
-%>


    // Problem
    appendLog("Define the problem...");
    
    // Integration rule
<%- helpers.indent(include('/blobs/integrationRules.edp.ejs'), 1) -%>

<% if (dimension !==2){ -%>
    appendError("Error, 3D is not supported);
    exit(- 1);
<% } -%>

    real penalty = <%- penalty[0].value ?? penalty[0].default -%>; // Penalty factor to penalize the interface conditions

    FE1 <%- unknownFunction1 -%>;
    FE2 <%- unknownFunction2 -%>;


    integrationRule(<% if (dimension === 2) { -%>"Gauss3"<% } else { -%>"Gauss"<% } -%>); // Function to apply the integration rule
    
<% if (dimension === 2){ -%>
    func real intpip(real tt, real X0, real X1) {
        // Interpolation function
        return(1 - tt) * X0 + tt * X1;
    }
    
    func real phi1(real tt, real iphi) {
        // shape functions on [0,1]
        if (iphi == 0) { return 1 - tt; }
        else { return tt; }
    }
<% } else { -%>
    func real phi1(real tt1, real tt2) {
        // First shape function on [0,1]
        return 1 - tt1 - tt2;
    }
    func real phi2(real tt1, real tt2) {
        // Second shape function on [0,1]
        return tt1;
    }
    func real phi3(real tt1, real tt2) {
        // Second shape function on [0,1]
        return tt2;
    }
    func real phi(real tt1, real tt2, int iph) {
        if (iph == 1) {
            return phi1(tt1, tt2);
        }
        else {
            if (iph == 2) {
                return phi2(tt1, tt2);
            }
            else {
                return phi3(tt1, tt2);
            }
        }
    }
<% } -%>
    // ////////////////////////////////////////////////
    
    // P1 functions
<%- helpers.indent(include('/blobs/P1Function.edp.ejs', {
    dimension
}), 1) -%>

    int dim = <%- dimension -%>;
    // Degree of Freedom
<% if (dimension === 2){ -%>
    fespace W1(Mesh0,[P1,P1]);
    fespace Wh2(Mesh1,[P1,P1]);
<% } else { -%>
    fespace Wh1(Mesh0,[P1,P1,P1]);
    fespace Wh2(Mesh1,[P1,P1,P1]);
<% } -%>

    int ndof1 = Wh1.ndof; // Number of the degree of freedom (x,y) for the first body
    int ndof2 = Wh2.ndof; // Number of the degree of freedom (x,y) for the second body

    int ndofA1 = FE1.ndof; // Number of the degree of freedom of potential A for the first body
    int ndofA2 = FE2.ndof; // Number of the degree of freedom for of potential A the second body
    
    // Extract contact borders for the body
    // Vectors & arrays for Contact
    int[int] Jb1, Jb2;
    int[int] dof1, dof2;
    int nC1 = 0;
    int nC2 = 0;
    
    // Extract contact borders for the body 1
    varf vcontbord(<%- testfunc2 -%>, <%- testfunc1 -%>) =
        // truc à la con pour éviter à gérer le + au début ou valeur vide
        intN(Mesh0)(0 * Vx)
<% for (const c of contactArea){ -%>
<%
        if (c.geometryIndex === 0){
        %>
        + on(<%- c.labels -%>, Wx = 1, Wy = 1 <% if (dimension !== 2){ -%>, Wz = 1 <% } -%>)
<% } -%>
<% } -%>
        ;
    real[int] onBorder1 = vcontbord(0, Wh1, tgv = 1);
    int numB1 = onBorder1.sum;
    nC1 = numB1 / dim; // Constraint number
<% if (dimension==2){ -%>
    Jb1.resize(numB1);
    int k = 0;
    for [i, B1i : onBorder1]
    if (B1i) { Jb1[k] = i; k++; }
<% } else { -%>
    dof1.resize(numB1);
    int k = 0;
    for (int i = 0; i < ndof1; i++) {
        if (onBorder1[i]) {
            dof1[k] = i;
            k++;
        }
    }
<% } -%>
    // End extract borders for the body 1
    
    // Extract contact borders for the body 2
    varf vcontbord2(<%- testfunc2 -%>, <%- testfunc1 -%>) =
        // truc à la con pour éviter à gérer le + au début ou valeur vide
        intN(Mesh1)(0 * Vx)
<% for (const c of contactArea){ -%>
<%
        if (c.geometryIndex === 1){
        %>
        + on(<%- c.labels -%>, Wx = 1, Wy = 1 <% if (dimension !== 2){ -%>, Wz = 1 <% } -%>)
<% } -%>
<% } -%>
        ;
    real[int] onBorder2 = vcontbord2(0, Wh2, tgv = 1);
    int numB2 = onBorder2.sum;
    nC2 = numB2 / dim; // Constraint number
<% if (dimension==2){ -%>
    Jb2.resize(numB2);
    k = 0;
    for [i, B2i : onBorder2]
    if (B2i) { Jb2[k] = i; k++; }
<% } else { -%>
    dof2.resize(numB2);
    k = 0;
    for (int i = 0; i < ndof2; i++) {
        if (onBorder2[i]) {
            dof2[k] = i;
            k++;
        }
    }
<% } -%>
    // End extract borders for the body 2
    
    // Working space (All internal variables are deleted after)
    real[int] XYZ1(ndof1);
    real[int] XYZ2(ndof2);
    {
<% if (dimension === 2){ -%>
        Wh1[xx1, yy1] = [x, y]; // position vector
        Wh2[xx2, yy2] = [x, y]; // position vector
<% } else { -%>
        Wh1[xx1, yy1, zz1] = [x, y, z]; // position vector
        Wh2[xx2, yy2, zz2] = [x, y, z]; // position vector
<% } -%>
        XYZ1 = xx1[];
        XYZ2 = xx2[];
    }
    // End working space
    
<%- helpers.indent(include('/blobs/connectivity2Bodies_2D.edp.ejs', {
    dimension
}), 1) -%>
<%- helpers.indent(include('/blobs/minimalSym2BodiesP1.edp.ejs'), 1) -%>
    
<% if (dimension === 2){ -%>
    int nElements1 = nC1 - 1; // Segment number at the contact area 1
    int nElements2 = nC2 - 1; // Segment number at the contact area 2
    int[int, int] Conne1(ndof1, 2); // Connectivity matrix Conne: for each dof at the contact area gives the segment (1,...,Mesh.nbe) connected to the dof
    int[int, int] Conne2(ndof2, 2); // Connectivity matrix Conne: for each dof at the contact area gives the segment (1,...,Th.nbe) connected to the dof
    int[int] Connevec1(ndof1); // Connectivity matrix vector Connevec: for each dof at the contact area gives the number of segment connected to the dof (1 or 2)
    int[int] Connevec2(ndof2); // Connectivity matrix vector Connevec: for each dof at the contact area gives the number of segment connected to the dof (1 or 2)
    int[int] segdof1(dim * Mesh.nbe); // For each segment of the border 1, gives the dofx of the two segment vertices
    int[int] segdof2(dim * Mesh2.nbe); // For each segment of the contact area 2, gives the dofx of the two segment vertices    
	int[int] segdofA1(dim*Mesh.nbe);  // For each segment of the border 1, gives the dofx of the two segment vertices for the potential A
	int[int] segdofA2(dim*Mesh2.nbe); // For each segment of the border 2, gives the dofx of the two segment vertices for the potential A		
	int[int, int] Conorm1(ndof1, 2); // Connectivity matrix Conorm: for each general dof => the segment (1,...,Mesh.nbe) connected to the dof
    int[int, int] Conorm2(ndof2, 2); // Connectivity matrix Conorm: for each general dof => the segment (1,...,Mesh2.nbe) connected to the dof
    int[int] Conormvec2(ndof2); // Connectivity matrix vector Conormvec: for each general dof gives the number of segments connected to the dof (1 or 2)
    int[int] Conormvec1(ndof1); // Connectivity matrix vector Conormvec: for each general dof gives the number of segments connected to the dof (1 or 2)
    int[int] vertdof1(Mesh.nbe); // dof of the triangle vertice that does not belonging to the border 1
    int[int] vertdof2(Mesh2.nbe); // dof of the triangle vertice that does not belonging to the border 2
    int[int] IDni1(Mesh.nbe); // For each boundary element "ni" in contact 1 gives the ID of the segment in 0,...,nseg1
    int[int] IDni2(Mesh2.nbe); // For each boundary element "ni" in contact 2 gives the ID of the segment in 0,...,nseg2
    int[int] segid1(nElements1); // For each contact element id in 0,...,nElements1 gives the ID of the segment in 0,...,Th.nbe
    int[int] segid2(nElements2); // For each contact element id in 0,...,nElements2 gives the ID of the segment in 0,...,Th.nbe
    int connecti = connectivity(nC1, nC2, Conne1, Conne2, Connevec1, Connevec2, segdof1, segdof2, segdofA1, segdofA2, vertdof1, vertdof2, onBorder1, onBorder2, IDni1, IDni2, segid1, segid2, Conorm1, Conorm2, Conormvec1, Conormvec2);
<% } else { -%>
    int[int, int] Conne1(ndof1, Mesh0.nt); // Connectivity matrix: for each dof the triangle connected to the dof
    int[int, int] Conne2(ndof2, Mesh1.nt); // Connectivity matrix Conne: for each dof at the contact area gives the segment (1,...,Th.nbe) connected to the dof
    int[int] Connevec1(ndof1); // Connectivity matrix vector: for each dof gives the number of triangles connected to the dof
    int[int] Connevec2(ndof2); // Connectivity matrix vector: for each dof gives the number of triangles connected to the dof
    int[int] tri1(Mesh0.nbe); // For each boundary element "ni" in contact 1 gives the ID of the triangle in 0,...,ntri1
    int[int] tri2(Mesh1.nbe); // For each boundary element "ni" in contact 2 gives the ID of the triangle in 0,...,ntri2
    int[int] tridof1(3 * Mesh0.nbe); // TRiangle dof \in contact area (3 dof because 3 vertices and corresponds to x dof)
    int[int, int] Conorm1(ndof1, Mesh0.nt); // Connectivity matrix Conorm: for each general dof => the triangle (1,...,Mesh0.nbe) connected to the dof
    int[int, int] Conorm2(ndof2, Mesh1.nt); // Connectivity matrix Conorm: for each general dof => the triangle (1,...,Mesh1.nbe) connected to the dof
    int[int] Conormvec1(ndof1); // Connectivity matrix vector Conormvec: for each general dof gives the number of triangles connected to the dof (1 or 2)
    int[int] Conormvec2(ndof2); // Connectivity matrix vector Conormvec: for each general dof gives the number of triangles connected to the dof (1 or 2)
    int[int] tridof2(3 * Mesh1.nbe); // Triangle dof \in contact area (3 dof because 3 vertices and corresponds to x dof)
    int[int] vertdof1(Mesh0.nbe); // dof of the thetraedron vertice that does not belonging to the contact area 1
    int[int] vertdof2(Mesh1.nbe); // dof of the thetraedron vertice that does not belonging to the contact area 2
    int[int] triid1(Mesh0.nbe); // For each contact element id in 0,...,ntri1 gives the ID of the triangle in 0,...,Mesh0.nbe
    int[int] triid2(Mesh1.nbe); // For each contact element id in 0,...,ntri1 gives the ID of the triangle in 0,...,Mesh1.nbe
    int nElements1, nElements2;
    // 3D is not yet considered
    //int connecti = connectivity(Conne1, Conne2, Connevec1, Connevec2, tri1, tri2, tridof1, tridof2, vertdof1, vertdof2, onBorder1, onBorder2, triid1, triid2, nElements1, nElements2, Conorm1, Conorm2, Conormvec1, Conormvec2);
    real[int] PO1(3), PO2(3), PO3(3), PO4(3); // Represent the coord of the three points of a triangle (we will use it to compute the normal vector)
<% } -%>
    
    int nip = nElements1 * integrationPointsNumber; // Ip points number
    int nip2 = nElements2 * integrationPointsNumber; // Ip points number
    
    real[int] xbU1(ndof1);
    real[int] xbU2(ndof2);
    real[int] xip1(dim * nip); // coordi of the ip points (First body)
    real[int] xip2(dim * nip2); // coordi of the ip points (Second body)
    real[int] Xproj(dim * nip); // coordi of the ip projection points (Second Body)
    real[int] Xproj2(dim * nip2); // coordi of the ip projection points (Second Body)
    
<% if (dimension === 2){ -%>
    int[int] pos(nip);
    int[int] pos2(nip2);
<% } else { -%>
    int[int] tid1(nip); // For each ip point gives the closest triangle id (1,...,Mesh1.nbe) of the opposed contact area
    int[int] tid2(nip2); // For each ip point gives the closest triangle id (1,...,Mesh0.nbe) of the opposed contact area
<% } -%>
    
    real norm0;
    real[int] DIS10(ndof1), DIS20(ndof2); // The displacement field from the previous iteration ( for the fixed point & to compute the error and stop the iteration)
    
    real[int] norm1(dim * nip), norm2(dim * nip2); // The normal (nx,ny) of the projected points
    
    // First Body
    real[int] eta((dim - 1) * nip); // Parameter array (Barycentric coordinates) for the P1 curve
    real[int] eta2((dim - 1) * nip2); // Parameter array (Barycentric coordinates) for the P1 curve
    

    real[int] AB(dim * dim);

	DIS10 = 0; // The displacement array of the first body 
	DIS20 = 0; // The displacement array of the second body 
	xbU1 = XYZ1;
	xbU2 = XYZ2;
        
        // Compute the projection points
        
        // First body
    for (int i = 0; i < nElements1; i++) {
        // 2D
<% if (dimension === 2){ -%>
        int seid1 = segid1[i]; // Seg ID w.r.t to the whole border
<% } -%>
        // 3D
<% if (dimension !== 2){ -%>
        int trid1 = triid1[i]; // Tri ID w.r.t to the whole border
<% } -%>
        for (int j = 0; j < integrationPointsNumber; j++) {
            int ii = j + i * integrationPointsNumber;
<% if (dimension === 2){ -%>
            real ti = integrationPointsPositions[j]; // The parameter of the ip point in the segment (integration rule)
            xip1[dim * ii] = intpip(ti, xbU1[segdof1[dim * seid1]], xbU1[segdof1[dim * seid1 + 1]]); // Abscissa of the ip points
            xip1[dim * ii + 1] = intpip(ti, xbU1[segdof1[dim * seid1] + 1], xbU1[segdof1[dim * seid1 + 1] + 1]); // Ordinates of the ip points
<% } -%>
<% if (dimension !== 2){ -%>
            real ti1 = integrationPointsPositions1[j]; // eta1 parameter of the triangle
            real ti2 = integrationPointsPositions2[j]; // eta2 parameter of the triangle
            for (int k = 0; k < 3; k++) { AB[k] = xbU1[tridof1[3 * trid1] + k]; }
            // coord of the first node of the triangle with id="i"
            for (int k = 0; k < 3; k++) { AB[k + 3] = xbU1[tridof1[3 * trid1 + 1] + k]; }
            // coord of the second node of the triangle with id="i"
            for (int k = 0; k < 3; k++) { AB[k + 6] = xbU1[tridof1[3 * trid1 + 2] + k]; }
            // coord of the third node of the triangle with id="i"
            real[int] P1X = P1Function(AB, ti1, ti2); // The coordinates of the ip points
            xip1[dim * ii] = P1X[0]; // x
            xip1[dim * ii + 1] = P1X[1]; // y
            xip1[dim * ii + 2] = P1X[2]; // z
<% } -%>
            
        }
    }
        
        // Second body
    for (int i = 0; i < nElements2; i++) {
        // 2D
<% if (dimension === 2){ -%>
        int seid2 = segid2[i]; // Seg ID w.r.t to the whole border
<% } -%>
        // 3D
<% if (dimension !== 2){ -%>
        int trid2 = triid2[i]; // Tri ID w.r.t to the whole border
<% } -%>
        for (int j = 0; j < integrationPointsNumber; j++) {
            int ii = j + i * integrationPointsNumber;
<% if (dimension === 2){ -%>
            real ti = integrationPointsPositions[j]; // The parameter of the ip point in the segment (integration rule)
            xip2[dim * ii] = intpip(ti, xbU2[segdof2[dim * seid2]], xbU2[segdof2[dim * seid2 + 1]]); // Abscissa of the ip points
            xip2[dim * ii + 1] = intpip(ti, xbU2[segdof2[dim * seid2] + 1], xbU2[segdof2[dim * seid2 + 1] + 1]); // Ordinates of the ip points
<% } -%>
<% if (dimension !== 2){ -%>
            real ti1 = integrationPointsPositions1[j]; // eta1 parameter of the triangle
            real ti2 = integrationPointsPositions2[j]; // eta2 parameter of the triangle
            for (int k = 0; k < 3; k++) { AB[k] = xbU2[tridof2[3 * trid2] + k]; }
            // coord of the first node of the triangle with id="i"
            for (int k = 0; k < 3; k++) { AB[k + 3] = xbU2[tridof2[3 * trid2 + 1] + k]; }
            // coord of the second node of the triangle with id="i"
            for (int k = 0; k < 3; k++) { AB[k + 6] = xbU2[tridof2[3 * trid2 + 2] + k]; }
            // coord of the third node of the triangle with id="i"
            real[int] P1X = P1Function(AB, ti1, ti2); // The coordinates of the ip points
            xip2[dim * ii] = P1X[0]; // x
            xip2[dim * ii + 1] = P1X[1]; // y
            xip2[dim * ii + 2] = P1X[2]; // z
<% } -%>
            
        }
    }
        
<% if (dimension === 2){ -%>
        eta = minim1(xip1, xbU2, pos, segdof2, DIS20); // Call the projection function => parameters array of the integration points
        eta2 = minim2(xip2, xbU1, pos2, segdof1, DIS10); // Call the projection function => parameters array of the integration points
<% } -%>
<% if (dimension !== 2){ -%>
        eta = minim1(xip1, tid1, xbU2, tridof2, DIS20);
        eta2 = minim2(xip2, tid2, xbU1, tridof1, DIS10);
<% } -%>
        
    real tx, ty;
    // First body (for each ip points of the contact 1 gives the normals at the contact 2 (continuous normal field))
    // Normal vector for the ip points at the contact area 2 (computed as the average of the normal vectors)
<% if (dimension !== 2){ -%>
    for (int i = 0; i < nElements1; i++) {
        // loop on the triangles of the contact area 1
        for (int j = 0; j < integrationPointsNumber; j++) {
            // loop on the integration points of each triangle
            int ii = j + i * integrationPointsNumber;                
            real et1 = eta[2 * ii]; // eta1 parameter of the triangle
            real et2 = eta[2 * ii + 1]; // eta2 parameter of the triangle
            int trid2 = tid1[ii]; // Triangle id \in contact area 2 closest to the integration point
            
            int dofp1 = tridof2[3 * trid2]; // dof x for the first node of the triangle with id="trid2"
            int dofp2 = tridof2[3 * trid2 + 1]; // dof x for the second node of the triangle with id="trid2"
            int dofp3 = tridof2[3 * trid2 + 2]; // dof x for the third node of the triangle with id="trid2"
            
            int conn1, conn2, conn3;
            if (tri2[trid2] == - 1) {
                // is a triangle of the contact potential area ?
                conn1 = Conormvec2[dofp1]; // Triangle number connected to the first node
                conn2 = Conormvec2[dofp2]; // Triangle number connected to the second node
                conn3 = Conormvec2[dofp3]; // Triangle number connected to the third node
            }
            else {
                conn1 = Connevec2[dofp1]; // Triangle number connected to the first node
                conn2 = Connevec2[dofp2]; // Triangle number connected to the second node
                conn3 = Connevec2[dofp3]; // Triangle number connected to the third node
            }
            
            real[int] vec1(3);
            real[int] vec2(3);
            real[int] vec3(3);
            real[int] provec(3);
            real[int] nor1(3), nor2(3), nor3(3);
            nor1 = 0.;
            nor2 = 0.;
            nor3 = 0.;
            for (int ic = 0; ic < conn1; ic++) {
                // Loop on the connected triangle to the first node
                int tic1;
                if (tri2[trid2] == - 1) {
                    // is a triangle of the contact potential area ?
                    tic1 = Conorm2(dofp1, ic); // Triangle id connected to the first node
                }
                else {
                    tic1 = Conne2(dofp1, ic); // Triangle id connected to the first node
                }
                for (int k = 0; k < 3; k++) { PO1[k] = xbU2[tridof2[3 * tic1] + k]; }
                // coord of the first node of the triangle with id="tic1"
                for (int k = 0; k < 3; k++) { PO2[k] = xbU2[tridof2[3 * tic1 + 1] + k]; }
                // coord of the second node of the triangle with id="tic1"
                for (int k = 0; k < 3; k++) { PO3[k] = xbU2[tridof2[3 * tic1 + 2] + k]; }
                // coord of the third node of the triangle with id="tic1"
                for (int k = 0; k < 3; k++) { PO4[k] = xbU2[vertdof2[tic1] + k]; }
                // coord of the third node of the thetraedron wich not belonging to the triangle
                vec1 = PO2 - PO1;
                vec2 = PO3 - PO1;
                vec3 = PO4 - PO1;
                provec = vectorProductNormalized(vec1, vec2); // Vectorial product
                if (provec' * vec3 > 0.) {
                    // scalar product is positive => -prodevec is exterior to the surface
                    provec = - provec; // Inverse the sign
                }
                nor1 += (1./ conn1) * provec; // Average of the normales of each connected triangle to the first node
            }
            nor1 = nor1 / ((nor1[0]^2 + nor1[1]^2 + nor1[2]^2)^0.5); // Unit normal at the first node
            
            for (int ic = 0; ic < conn2; ic++) {
                // Loop on the connected triangle to the second node
                int tic2;
                if (tri2[trid2] == - 1) {
                    // is a triangle of the contact potential area ?
                    tic2 = Conorm2(dofp2, ic); // Triangle id connected to the first node
                }
                else {
                    tic2 = Conne2(dofp2, ic); // Triangle id connected to the first node
                }
                for (int k = 0; k < 3; k++) { PO1[k] = xbU2[tridof2[3 * tic2] + k]; }
                // coord of the first node of the triangle with id="tic2"
                for (int k = 0; k < 3; k++) { PO2[k] = xbU2[tridof2[3 * tic2 + 1] + k]; }
                // coord of the second node of the triangle with id="tic2"
                for (int k = 0; k < 3; k++) { PO3[k] = xbU2[tridof2[3 * tic2 + 2] + k]; }
                // coord of the third node of the triangle with id="tic2"
                for (int k = 0; k < 3; k++) { PO4[k] = xbU2[vertdof2[tic2] + k]; }
                // coord of the third node of the thetraedron wich not belonging to the triangle
                vec1 = PO2 - PO1;
                vec2 = PO3 - PO1;
                vec3 = PO4 - PO1;
                provec = vectorProductNormalized(vec1, vec2); // Vectorial product
                if (provec' * vec3 > 0.) {
                    // scalar product is positive => -prodevec is exterior to the surface
                    provec = - provec; // Inverse the sign
                }
                nor2 += (1./ conn2) * provec; // Average of the normales of each connected triangle to the second node
            }
            nor2 = nor2 / ((nor2[0]^2 + nor2[1]^2 + nor2[2]^2)^0.5); // Unit normal at the second node
            
            for (int ic = 0; ic < conn3; ic++) {
                // Loop on the connected triangle to the third node
                int tic3;
                if (tri2[trid2] == - 1) {
                    // is a triangle of the contact potential area ?
                    tic3 = Conorm2(dofp3, ic); // Triangle id connected to the first node
                }
                else {
                    tic3 = Conne2(dofp3, ic); // Triangle id connected to the first node
                }
                for (int k = 0; k < 3; k++) { PO1[k] = xbU2[tridof2[3 * tic3] + k]; }
                // coord of the first node of the triangle with id="tic3"
                for (int k = 0; k < 3; k++) { PO2[k] = xbU2[tridof2[3 * tic3 + 1] + k]; }
                // coord of the second node of the triangle with id="tic3"
                for (int k = 0; k < 3; k++) { PO3[k] = xbU2[tridof2[3 * tic3 + 2] + k]; }
                // coord of the third node of the triangle with id="tic3"
                for (int k = 0; k < 3; k++) { PO4[k] = xbU2[vertdof2[tic3] + k]; }
                // coord of the third node of the thetraedron wich not belonging to the triangle
                vec1 = PO2 - PO1;
                vec2 = PO3 - PO1;
                vec3 = PO4 - PO1;
                provec = vectorProductNormalized(vec1, vec2); // Vectorial product
                if (provec' * vec3 > 0.) {
                    // scalar product is positive => -prodevec is exterior to the surface
                    provec = - provec; // Inverse the sign
                }
                nor3 += (1./ conn3) * provec; // Average of the normales of each connected triangle to the third node
            }
            nor3 = nor3 / ((nor3[0]^2 + nor3[1]^2 + nor3[2]^2)^0.5); // Unit normal at the third node
            
            AB(0 : 2) = nor1;
            AB(3 : 5) = nor2;
            AB(6 : 8) = nor3;
            real[int] NX = P1Function(AB, et1, et2); // The coordinates of the ip points
            norm1[3 * ii] = NX[0]; // x coord of the normal at the ip point
            norm1[3 * ii + 1] = NX[1]; // y	coord of the normal at the ip point
            norm1[3 * ii + 2] = NX[2]; // z	coord of the normal at the ip point         
        }
    }
<% } -%
       
    // Second body (for each ip points of the contact 1 gives the normals at the contact 1 (continuous normal field))
    // Normal vector for the ip points at the contact area 1 (computed as the average of the normal vectors)
    <% if (dimension !== 2){ -%>
    for (int i = 0; i < nElements2; i++) {
        // loop on the triangles of the contact area 1
        for (int j = 0; j < integrationPointsNumber; j++) {
            // loop on the integration points of each triangle
            int ii = j + i * integrationPointsNumber;           
            real et1 = eta2[2 * ii]; // eta1 parameter of the triangle
            real et2 = eta2[2 * ii + 1]; // eta2 parameter of the triangle
            int trid2 = tid2[ii]; // Triangle id \in contact area 1 closest to the integration point
            
            int dofp1 = tridof1[3 * trid2]; // dof x for the first node of the triangle with id="trid2"
            int dofp2 = tridof1[3 * trid2 + 1]; // dof x for the second node of the triangle with id="trid2"
            int dofp3 = tridof1[3 * trid2 + 2]; // dof x for the third node of the triangle with id="trid2"
            
            int conn1, conn2, conn3;
            if (tri1[trid2] == - 1) {
                // is a triangle of the contact potential area ?
                conn1 = Conormvec1[dofp1]; // Triangle number connected to the first node
                conn2 = Conormvec1[dofp2]; // Triangle number connected to the second node
                conn3 = Conormvec1[dofp3]; // Triangle number connected to the third node
            }
            else {
                conn1 = Connevec1[dofp1]; // Triangle number connected to the first node
                conn2 = Connevec1[dofp2]; // Triangle number connected to the second node
                conn3 = Connevec1[dofp3]; // Triangle number connected to the third node
            }
            
            real[int] vec1(3);
            real[int] vec2(3);
            real[int] vec3(3);
            real[int] provec(3);
            real[int] nor1(3), nor2(3), nor3(3);
            nor1 = 0.;
            nor2 = 0.;
            nor3 = 0.;
            for (int ic = 0; ic < conn1; ic++) {
                // Loop on the connected triangle to the first node
                int tic1;
                if (tri1[trid2] == - 1) {
                    // is a triangle of the contact potential area ?
                    tic1 = Conorm1(dofp1, ic); // Triangle id connected to the first node
                }
                else {
                    tic1 = Conne1(dofp1, ic); // Triangle id connected to the first node
                }
                for (int k = 0; k < 3; k++) { PO1[k] = xbU1[tridof1[3 * tic1] + k]; }
                // coord of the first node of the triangle with id="tic1"
                for (int k = 0; k < 3; k++) { PO2[k] = xbU1[tridof1[3 * tic1 + 1] + k]; }
                // coord of the second node of the triangle with id="tic1"
                for (int k = 0; k < 3; k++) { PO3[k] = xbU1[tridof1[3 * tic1 + 2] + k]; }
                // coord of the third node of the triangle with id="tic1"
                for (int k = 0; k < 3; k++) { PO4[k] = xbU1[vertdof1[tic1] + k]; }
                // coord of the third node of the thetraedron wich not belonging to the triangle
                vec1 = PO2 - PO1;
                vec2 = PO3 - PO1;
                vec3 = PO4 - PO1;
                provec = vectorProductNormalized(vec1, vec2); // Vectorial product
                if (provec' * vec3 > 0.) {
                    // scalar product is positive => -prodevec is exterior to the surface
                    provec = - provec; // Inverse the sign
                }
                nor1 += (1./ conn1) * provec; // Average of the normales of each connected triangle to the first node
            }
            nor1 = nor1 / ((nor1[0]^2 + nor1[1]^2 + nor1[2]^2)^0.5); // Unit normal at the first node
            
            for (int ic = 0; ic < conn2; ic++) {
                // Loop on the connected triangle to the second node
                int tic2;
                if (tri1[trid2] == - 1) {
                    // is a triangle of the contact potential area ?
                    tic2 = Conorm1(dofp2, ic); // Triangle id connected to the first node
                }
                else {
                    tic2 = Conne1(dofp2, ic); // Triangle id connected to the first node
                }
                for (int k = 0; k < 3; k++) { PO1[k] = xbU1[tridof1[3 * tic2] + k]; }
                // coord of the first node of the triangle with id="tic2"
                for (int k = 0; k < 3; k++) { PO2[k] = xbU1[tridof1[3 * tic2 + 1] + k]; }
                // coord of the second node of the triangle with id="tic2"
                for (int k = 0; k < 3; k++) { PO3[k] = xbU1[tridof1[3 * tic2 + 2] + k]; }
                // coord of the third node of the triangle with id="tic2"
                for (int k = 0; k < 3; k++) { PO4[k] = xbU1[vertdof1[tic2] + k]; }
                // coord of the third node of the thetraedron wich not belonging to the triangle
                vec1 = PO2 - PO1;
                vec2 = PO3 - PO1;
                vec3 = PO4 - PO1;
                provec = vectorProductNormalized(vec1, vec2); // Vectorial product
                if (provec' * vec3 > 0.) {
                    // scalar product is positive => -prodevec is exterior to the surface
                    provec = - provec; // Inverse the sign
                }
                nor2 += (1./ conn2) * provec; // Average of the normales of each connected triangle to the second node
            }
            nor2 = nor2 / ((nor2[0]^2 + nor2[1]^2 + nor2[2]^2)^0.5); // Unit normal at the second node
            
            for (int ic = 0; ic < conn3; ic++) {
                // Loop on the connected triangle to the third node
                int tic3;
                if (tri1[trid2] == - 1) {
                    // is a triangle of the contact potential area ?
                    tic3 = Conorm1(dofp3, ic); // Triangle id connected to the first node
                }
                else {
                    tic3 = Conne1(dofp3, ic); // Triangle id connected to the first node
                }
                for (int k = 0; k < 3; k++) { PO1[k] = xbU1[tridof1[3 * tic3] + k]; }
                // coord of the first node of the triangle with id="tic3"
                for (int k = 0; k < 3; k++) { PO2[k] = xbU1[tridof1[3 * tic3 + 1] + k]; }
                // coord of the second node of the triangle with id="tic3"
                for (int k = 0; k < 3; k++) { PO3[k] = xbU1[tridof1[3 * tic3 + 2] + k]; }
                // coord of the third node of the triangle with id="tic3"
                for (int k = 0; k < 3; k++) { PO4[k] = xbU1[vertdof1[tic3] + k]; }
                // coord of the third node of the thetraedron wich not belonging to the triangle
                vec1 = PO2 - PO1;
                vec2 = PO3 - PO1;
                vec3 = PO4 - PO1;
                provec = vectorProductNormalized(vec1, vec2); // Vectorial product
                if (provec' * vec3 > 0.) {
                    // scalar product is positive => -prodevec is exterior to the surface
                    provec = - provec; // Inverse the sign
                }
                nor3 += (1./ conn3) * provec; // Average of the normales of each connected triangle to the third node
            }
            nor3 = nor3 / ((nor3[0]^2 + nor3[1]^2 + nor3[2]^2)^0.5); // Unit normal at the third node
            
            AB(0 : 2) = nor1;
            AB(3 : 5) = nor2;
            AB(6 : 8) = nor3;
            real[int] NX = P1Function(AB, et1, et2); // The coordinates of the ip points
            norm2[3 * ii] = NX[0]; // x coord of the normal at the ip point
            norm2[3 * ii + 1] = NX[1]; // y	coord of the normal at the ip point
            norm2[3 * ii + 2] = NX[2]; // z	coord of the normal at the ip point
        }
    }
<% } -%>            


<%# Solve -%>
        // Solve
        appendLog("Solve the problem...");
// First Body 
    real Nu1 = 1. / Mu0;
    varf vLaplacian1 (<%- unknownFunction1 -%>, <%- testFunction1 -%>)
        = intN(<%- mesh.name -%>) (
            Nu1 * Curl(<%- unknownFunction1 -%>)' * Curl(<%- testFunction1 -%>)
<% if (dimension !== 2) { -%>
            + penalty * Div(<%- unknownFunction1 -%>) * Div(<%- testFunction1 -%>)
<% } -%>
        )
<% for (const d of dirichletProd){ -%>
    <% if (c.geometryIndex === 0){ %>
        <% if (dimension === 2) { -%>
            +on(<%- d.labels -%>,unknownFunction1Z = <%- d.values[0].value ?? d.values[0].default -%> )
        <% } else { -%>
            + intN1(<%- mesh.name -%>, <%- d.labels -%>) (
                penalty * DotNormal(<%- unknownFunction1 -%>)' * DotNormal(<%- testFunction1 -%>)
            )
        <% } -%>
    <% } -%>
<% } -%>
        ;
    
    varf vLaplacianRHS1 (<%- unknownFunction1 -%>, <%- testFunction1 -%>)
        = intN(<%- mesh.name -%>) (
<% if (dimension === 2) { -%>
            <%- currentValueZ -%> * <%- testFunction1 %>
<% } else { -%>
            [<%- currentValueX -%>, <%- currentValueY -%>, <%- currentValueZ -%>]' * <%- testFunction1 %>
<% } -%>
        )
<% for (const d of dirichletProd){ -%>

    <% if (c.geometryIndex === 0){ %>
        <% if (dimension === 2) { -%> 
        + on(<%- d.labels -%>,unknownFunction1Z = <%- d.values[0].value ?? d.values[0].default -%> )
        <% } else { -%>
        + intN1(<%- mesh.name -%>, <%- d.labels -%>) (
            penalty *
                [
                    0<% if (d.values[0].checked){ -%> + <%- d.values[0].value ?? d.values[0].default -%><% } -%>,
                    0<% if (d.values[1].checked){ -%> + <%- d.values[1].value ?? d.values[1].default -%><% } -%>,
                    0<% if (d.values[2].checked){ -%> + <%- d.values[2].value ?? d.values[2].default -%><% } %>
                ]' * DotNormal(<%- testFunction1 -%>))
        <% } -%>
    <% } -%>        
<% } -%>
        ;

// Second Body 
    real Nu2 = 1. / Mu1;
    varf vLaplacian2 (<%- unknownFunction2 -%>, <%- testFunction2 -%>)
        = intN(<%- mesh.name -%>) (
            Nu2 * Curl(<%- unknownFunction2 -%>)' * Curl(<%- testFunction2 -%>)
<% if (dimension !== 2) { -%>
            + penalty * Div(<%- unknownFunction2 -%>) * Div(<%- testFunction2 -%>)
<% } -%>
        )
<% for (const d of dirichletProd){ -%>
    <% if (c.geometryIndex === 1){ %>
        <% if (dimension === 2) { -%>
            +on(<%- d.labels -%>,unknownFunction2Z = <%- d.values[0].value ?? d.values[0].default -%> )
        <% } else { -%>
            + intN1(<%- mesh.name -%>, <%- d.labels -%>) (
                penalty * DotNormal(<%- unknownFunction2 -%>)' * DotNormal(<%- testFunction2 -%>)
            )
        <% } -%>
    <% } -%>
<% } -%>
        ;
    
    varf vLaplacianRHS2 (<%- unknownFunction2 -%>, <%- testFunction2 -%>)
        = intN(<%- mesh.name -%>) (
<% if (dimension === 2) { -%>
            <%- currentValueZ -%> * <%- testFunction2 %>
<% } else { -%>
            [<%- currentValueX -%>, <%- currentValueY -%>, <%- currentValueZ -%>]' * <%- testFunction2 %>
<% } -%>
        )
<% for (const d of dirichletProd){ -%>

    <% if (c.geometryIndex === 1){ %>
        <% if (dimension === 2) { -%> 
        + on(<%- d.labels -%>,unknownFunction2Z = <%- d.values[0].value ?? d.values[0].default -%> )
        <% } else { -%>
        + intN1(<%- mesh.name -%>, <%- d.labels -%>) (
            penalty *
                [
                    0<% if (d.values[0].checked){ -%> + <%- d.values[0].value ?? d.values[0].default -%><% } -%>,
                    0<% if (d.values[1].checked){ -%> + <%- d.values[1].value ?? d.values[1].default -%><% } -%>,
                    0<% if (d.values[2].checked){ -%> + <%- d.values[2].value ?? d.values[2].default -%><% } %>
                ]' * DotNormal(<%- testFunction2 -%>))
        <% } -%>
    <% } -%>        
<% } -%>
        ;

        
        // The energy and its differentials
        func real iW(real[int] &D) {
            Wh1<%- interfunc1 -%>; // [D1x, D1y] if dim=2 and [D1x, D1y, D1z] if dim=3
            D1x[] = D(0 : (ndof1 - 1));
            Wh2<%- interfunc2 -%>; // [D2x, D2y] if dim=2 and [D2x, D2y, D2z] if dim=3
            D2x[] = D(ndof1 : (ndoft - 1));
            
            real res = intN(Mesh0)(W2d0(<%- interfunc1 -%>)) + intN(Mesh1)(W2d1(<%- interfunc2 -%>));
<% for (const p of pressure){ -%>
<%
if (p.geometryIndex === 0){
%>
            res += - intN1(Mesh0, <%- p.labels -%>)(
                (<%- p.values[0].value ?? p.values[0].default -%>) * <%- N -%>' * <%- interfunc1 -%>
            );
<% } else { -%>
            res += - intN1(Mesh1, <%- p.labels -%>)(
                (<%- p.values[0].value ?? p.values[0].default -%>) * <%- N -%>' * <%- interfunc2 -%>
            );
<% } -%>
<% } -%>

<% for (const p of componentsPresure){ -%>
<%
if (p.geometryIndex === 0){ 
%>
            res += - intN1(Mesh0, <%- p.labels -%>)(
                (<%- p.values[0].value ?? p.values[0].default -%>) * D1x
                + (<%- p.values[1].value ?? p.values[1].default -%>) * D1y
<% if (dimension != 2){ -%>
                + (<%- p.values[2].value ?? p.values[2].default -%>) * D1z
<% } -%>                
            );
<% } else { -%>
            res += - intN1(Mesh1, <%- p.labels -%>)(
                (<%- p.values[0].value ?? p.values[0].default -%>) * D2x
                + (<%- p.values[1].value ?? p.values[1].default -%>) * D2y
<% if (dimension != 2){ -%>
                + (<%- p.values[2].value ?? p.values[2].default -%>) * D2z
<% } -%>  
            );
<% } -%>
<% } -%>

            res += - intN(Mesh0)(<% if (dimension === 2){ -%>[<%- gForceX -%> * Rho0 + <%- forceX -%>, <%- gForceY -%> * Rho0 + <%- forceY -%>]' * <%- interfunc1%>
<% } else { -%>[<%- gForceX -%> * Rho0 + <%- forceX -%>, <%- gForceY -%> * Rho0 + <%- forceY -%>, <%- gForceZ -%> * Rho0 + <%- forceZ -%>]' * <%- interfunc1%>
<% } -%>);
            res += - intN(Mesh1)(<% if (dimension === 2){ -%>[<%- gForceX -%> * Rho1 + <%- forceX -%>, <%- gForceY -%> * Rho1 + <%- forceY -%>]' * <%- interfunc2%>
<% } else { -%>[<%- gForceX -%> * Rho1 + <%- forceX -%>, <%- gForceY -%> * Rho1 + <%- forceY -%>, <%- gForceZ -%> * Rho1 + <%- forceZ -%>]' * <%- interfunc1%>
<% } -%>);
            
            real[int] X1(ndof1);
            real[int] X2(ndof1 : (ndoft - 1));
            X1 = D(0 : (ndof1 - 1));
            X2 = D(ndof1 : (ndoft - 1));
            // For quasi-static friction
            real[int] Xn1(ndof1);
            real[int] Xn2(ndof1 : (ndoft - 1));
            Xn1 = D1x1[]; // = U of the previous increment n*
            Xn2 = D2x2[]; // = U of the previous increment n
            X1 -= Xn1; // = Un+1 -Un
            X2 -= Xn2; // = Un+1 -Un on the contact area of the second body
            // //////////////////////////
            if (tresca) {
                // the normal pressure is now computed
<% if (dimension === 2){ -%>
                real Li;
<% } -%>
<% if (dimension !== 2){ -%>
                real[int] ABT10(9), ve1(3), ve2(3), provec(3);
                real Si;
<% } -%>
                for (int i = 0; i < nContactElements; i++) {
                    // Loop on the segment/triangle in contact
<% if (dimension === 2){ -%>
                    int idseg = contactElements[i]; // Segment id in 0,...nseg1
                    int seid1 = segid1[idseg]; // Seg ID w.r.t to the whole border
                    int dofx0 = segdof1[2 * seid1]; // dof x of the first vertice of the segment
                    int dofx1 = segdof1[2 * seid1 + 1]; // dof x of the secondt vertice of the segment
                    // Integral on the surface of the previous iteration where there is a contact => Fixed point for the Tresca problem
                    Li = ((xbU1[dofx1] - xbU1[dofx0])^2 + (xbU1[dofx1 + 1] - xbU1[dofx0 + 1])^2)^0.5; // Length due to the integral by substitution
                    for (int j = 0; j < integrationPointsNumber; j++) {
                        // shape function of the first segment
                        int ii = j + idseg * integrationPointsNumber;
                        
                        real tt = eta[ii];
                        int posi = pos[ii]; // The segment number w.r.t to the whole border of the closest segment
                        int dofp1 = segdof2[2 * posi]; // Dof x of the first vertice of the segment
                        int dofp2 = segdof2[2 * posi + 1]; // Dof x of the second vertice of the segment
                        AB[0] = X2[dofp1];
                        AB[1] = X2[dofp1 + 1];
                        AB[2] = X2[dofp2];
                        AB[3] = X2[dofp2 + 1];
                        real[int] P1X1 = P1Function(AB, tt); // Segment [x0,x1] => the closest point of (xp,yp) to the segment
                        real uprx = P1X1[0]; // The projected points on the contact area 2
                        real upry = P1X1[1];
                        
                        real ti = integrationPointsPositions[j]; // the parameter of the ip point in the segment (integration rule)
                        real wi = integrationPointsWeights[j]; // weight integration rule
                        real uxi = intpip(ti, X1[dofx0], X1[dofx1]); // displacement x of the ip points
                        real uyi = intpip(ti, X1[dofx0 + 1], X1[dofx1 + 1]); // displacement y of the ip points
                        res += - mucol * s[ii] * phiEpsilon((uxi - uprx) * (1. - norm1[2 * ii] * norm1[2 * ii]) - (uyi - upry) * norm1[2 * ii + 1] * norm1[2 * ii], - (uxi - uprx) * norm1[2 * ii] * norm1[2 * ii + 1] + (uyi - upry) * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]), epsphi) * wi * Li;
                    }
<% } else { -%>
                    int idseg = contactElements[i]; // triangle in contact id (0,...,ntri1)
                    int trid1 = triid1[idseg]; // Tri ID w.r.t to the whole border (0,...,Mesh0.nbe)
                    for (int k = 0; k < 3; k++) { ABT10[k] = xbU1[tridof1[3 * trid1] + k]; }
                    // coord of the first node of the triangle with id="trid1"
                    for (int k = 0; k < 3; k++) { ABT10[k + 3] = xbU1[tridof1[3 * trid1 + 1] + k]; }
                    // coord of the second node of the triangle with id="trid1"
                    for (int k = 0; k < 3; k++) { ABT10[k + 6] = xbU1[tridof1[3 * trid1 + 2] + k]; }
                    // coord of the third node of the triangle with id="trid1"
                    PO1 = ABT10(0 : 2); // First point of the triangle
                    PO2 = ABT10(3 : 5); // Second point of the triangle
                    PO3 = ABT10(6 : 8); // Third point of the triangle
                    ve1 = PO2 - PO1;
                    ve2 = PO3 - PO1;
                    provec = vectorProduct(ve1, ve2); // Vectorial product in order to compute the area of the triangle (previous iteration) where the integration is done
                    Si = (provec[0]^2 + provec[1]^2 + provec[2]^2)^0.5; // = 2* The surface of the (previous iteration) triangle where the integration is done (contact area 1), correspond to variable changes in the surface integral
                    
                    for (int j = 0; j < integrationPointsNumber; j++) {
                        // loop on ip points
                        int ii = j + idseg * integrationPointsNumber;
                        real ti1 = integrationPointsPositions1[j]; // the parameter of the ip point in the triangle (integration rule)
                        real ti2 = integrationPointsPositions2[j];
                        real wi = integrationPointsWeights[j]; // weight integration rule
                        
                        for (int k = 0; k < 3; k++) { AB[k] = X1[tridof1[3 * trid1] + k]; }
                        // u of the first node of the triangle with id="trid1"
                        for (int k = 0; k < 3; k++) { AB[k + 3] = X1[tridof1[3 * trid1 + 1] + k]; }
                        // u of the second node of the triangle with id="trid1"
                        for (int k = 0; k < 3; k++) { AB[k + 6] = X1[tridof1[3 * trid1 + 2] + k]; }
                        // u of the third node of the triangle with id="trid1"
                        
                        real[int] P1X = P1Function(AB, ti1, ti2); // The coordinates of the ip points
                        real ux = P1X[0]; // x
                        real uy = P1X[1]; // y
                        real uz = P1X[2]; // z
                        
                        // projection here
                        real et1 = eta[2 * ii]; // eta1 parameter of the triangle
                        real et2 = eta[2 * ii + 1]; // eta2 parameter of the triangle
                        int trid2 = tid1[ii]; // Triangle id \in contact area 2 closest to the integration point
                        
                        for (int k = 0; k < 3; k++) { AB[k] = X2[tridof2[3 * trid2] + k]; }
                        // coord of the first node of the triangle with id="trid2"
                        for (int k = 0; k < 3; k++) { AB[k + 3] = X2[tridof2[3 * trid2 + 1] + k]; }
                        // coord of the second node of the triangle with id="trid2"
                        for (int k = 0; k < 3; k++) { AB[k + 6] = X2[tridof2[3 * trid2 + 2] + k]; }
                        // coord of the third node of the triangle with id="trid2"
                        P1X = P1Function(AB, et1, et2); // The coordinates of the ip points
                        real uxpr = P1X[0]; // x of the projected point on the surface 2 for the ip points at the contact area 1
                        real uypr = P1X[1]; // y of the projected point on the surface 2 for the ip points at the contact area 1
                        real uzpr = P1X[2]; // z of the projected point on the surface 2 for the ip points at the contact area 1
                        
                        real[int, int] Pt(3, 3); // Matrix to give the tangential part of a vector
                        Pt = [[1. - norm1[3 * ii] * norm1[3 * ii], - norm1[3 * ii] * norm1[3 * ii + 1], - norm1[3 * ii] * norm1[3 * ii + 2]],
                            [- norm1[3 * ii] * norm1[3 * ii + 1], 1. - norm1[3 * ii + 1] * norm1[3 * ii + 1], - norm1[3 * ii + 1] * norm1[3 * ii + 2]],
                            [- norm1[3 * ii] * norm1[3 * ii + 2], - norm1[3 * ii + 1] * norm1[3 * ii + 2], 1. - norm1[3 * ii + 2] * norm1[3 * ii + 2]]];
                        real[int] urt(3); // relative tangential displacement vector
                        urt = [ux - uxpr, uy - uypr, uz - uzpr];
                        urt = Pt * urt;
                        res += - mucol * s[ii] * phiEpsilon(urt[0], urt[1], urt[2], epsphi) * wi * Si;
                    }
<% } -%>
                }
            }
            
            return res;
        }
        
        // The energy differential
        func real[int] idW(real[int] &D) {
            Wh1<%- interfunc1 -%>; // [D1x, D1y] if dim=2 and [D1x, D1y, D1z] if dim=3
            D1x[] = D(0 : (ndof1 - 1));
            Wh2<%- interfunc2 -%>; // [D2x, D2y] if dim=2 and [D2x, D2y, D2z] if dim=3
            D2x[] = D(ndof1 : (ndoft - 1));
            
            varf dWW1(<%- testfunc2 -%>, <%- testfunc1 -%>)
                = intN(Mesh0)(dW2d0(<%- interfunc1 -%>, <%- testfunc1 -%>))
<% for (const p of pressure){ -%>
<%
if (p.geometryIndex === 0){
%>
                - intN1(Mesh0, <%- p.labels -%>)(
                    (<%- p.values[0].value ?? p.values[0].default -%>) * <%- N -%>' * <%- testfunc1 -%>
                )
<% } -%>
<% } -%>
<% for (const p of componentsPresure){ -%>
<%
if (p.geometryIndex === 0){ 
%>
                - intN1(Mesh0, <%- p.labels -%>)(
                (<%- p.values[0].value ?? p.values[0].default -%>) * Vx
                + (<%- p.values[1].value ?? p.values[1].default -%>) * Vy
<% if (dimension != 2){ -%>
                + (<%- p.values[2].value ?? p.values[2].default -%>) * Vz
<% } -%>                
            )
<% } -%>
<% } -%>
                - intN(Mesh0)(<% if (dimension === 2){ -%>[<%- gForceX -%> * Rho0 + <%- forceX -%>, <%- gForceY -%> * Rho0 + <%- forceY -%>]' * <%- testfunc1%>
<% } else { -%>[<%- gForceX -%> * Rho0 + <%- forceX -%>, <%- gForceY -%> * Rho0 + <%- forceY -%>, <%- gForceZ -%> * Rho0 + <%- forceZ -%>]' * <%- testfunc1%>
<% } -%>)
                ;
            real[int] idWW1 = dWW1(0, Wh1);
            
            varf dWW2(<%- testfunc2 -%>, <%- testfunc1 -%>)
                = intN(Mesh1)(dW2d1(<%- interfunc2 -%>, <%- testfunc1 -%>))
<% for (const p of pressure){ -%>
<%
if (p.geometryIndex === 1){
%>
                - intN1(Mesh1, <%- p.labels -%>)(
                    (<%- p.values[0].value ?? p.values[0].default -%>) * <%- N -%>' * <%- testfunc1 -%>
                )
<% } -%>
<% } -%>
<% for (const p of componentsPresure){ -%>
<%
if (p.geometryIndex === 1){ 
%>
                - intN1(Mesh1, <%- p.labels -%>)(
                (<%- p.values[0].value ?? p.values[0].default -%>) * Vx
                + (<%- p.values[1].value ?? p.values[1].default -%>) * Vy
<% if (dimension != 2){ -%>
                + (<%- p.values[2].value ?? p.values[2].default -%>) * Vz
<% } -%>                
            )
<% } -%>
<% } -%>


                - intN(Mesh1)(<% if (dimension === 2){ -%>[<%- gForceX -%> * Rho1 + <%- forceX -%>, <%- gForceY -%> * Rho1 + <%- forceY -%>]' * <%- testfunc1%>
<% } else { -%>[<%- gForceX -%> * Rho1 + <%- forceX -%>, <%- gForceY -%> * Rho1 + <%- forceY -%>, <%- gForceZ -%> * Rho1 + <%- forceZ -%>]' * <%- testfunc1%>
<% } -%>)
                ;
            real[int] idWW2 = dWW2(0, Wh2);
            
            real[int] idWW(ndoft);
            idWW(0 : (ndof1 - 1)) = idWW1; // Energy gradient for the first body
            idWW(ndof1 : (ndoft - 1)) = idWW2; // Energy gradient for the sedcond body
            
            real[int] X1(ndof1);
            real[int] X2(ndof1 : (ndoft - 1));
            X1 = D(0 : (ndof1 - 1));
            X2 = D(ndof1 : (ndoft - 1));
            
            // For quasi-static friction
            real[int] Xn1(ndof1);
            real[int] Xn2(ndof1 : (ndoft - 1));
            Xn1 = D1x1[]; // = U of the previous increment n
            Xn2 = D2x2[]; // = U of the previous increment n
            X1 -= Xn1; // = Un+1 -Un
            X2 -= Xn2; // = Un+1 -Un on the contact area of the second body
            // //////////////////////////
            
            if (tresca) {
                // the normal pressure is now computed
<% if (dimension === 2){ -%>
                real Li;
<% } -%>
<% if (dimension !== 2){ -%>
                real[int] ABT10(9), ve1(3), ve2(3), provec(3);
                real Si;
<% } -%>
                
                for (int i = 0; i < nContactElements; i++) {
                    // Loop on the segment/triangle in contact
<% if (dimension === 2){ -%>
                    int idseg = contactElements[i]; // Segment id in 0,...nseg1
                    int seid1 = segid1[idseg]; // Seg ID w.r.t to the whole border
                    int dofx0 = segdof1[2 * seid1]; // dof x of the first vertice of the segment
                    int dofx1 = segdof1[2 * seid1 + 1]; // dof x of the secondt vertice of the segment
                    // Integral on the surface of the previous iteration where there is a contact => Fixed point for the Tresca problem
                    Li = ((xbU1[dofx1] - xbU1[dofx0])^2 + (xbU1[dofx1 + 1] - xbU1[dofx0 + 1])^2)^0.5; // Length due to the integral by substitution
                    for (int j = 0; j < integrationPointsNumber; j++) {
                        // shape function of the first segment
                        int ii = j + idseg * integrationPointsNumber;
                        
                        real tt = eta[ii];
                        real ph1 = 1 - tt;
                        real ph2 = tt;
                        
                        int posi = pos[ii]; // The segment number w.r.t to the whole border of the closest segment
                        int dofp1 = segdof2[2 * posi]; // Dof x of the first vertice of the segment
                        int dofp2 = segdof2[2 * posi + 1]; // Dof x of the second vertice of the segment
                        AB[0] = X2[dofp1];
                        AB[1] = X2[dofp1 + 1];
                        AB[2] = X2[dofp2];
                        AB[3] = X2[dofp2 + 1];
                        real[int] P1X1 = P1Function(AB, tt); // Segment [x0,x1] => the closest point of (xp,yp) to the segment
                        real uprx = P1X1[0]; // The projected points on the contact area 2
                        real upry = P1X1[1];
                        
                        real ti = integrationPointsPositions[j]; // the parameter of the ip point in the segment (integration rule)
                        real wi = integrationPointsWeights[j]; // weight integration rule
                        real uxi = intpip(ti, X1[dofx0], X1[dofx1]); // displacement x of the ip points
                        real uyi = intpip(ti, X1[dofx0 + 1], X1[dofx1 + 1]); // displacement y of the ip points
                        
                        // ///////////
                        // phiEpsilon(,)= f(.,.) ° (g1,g2) => a_{u1}(f)= a_{g1}(f)°(g1,g2) * a_{u1}(g1) + a_{g2}(f)°(g1,g2) * a_{u2}(g2)
                        real au1g1 = (1 - ti) * (1. - norm1[2 * ii] * norm1[2 * ii]); // a_{u1}(g1)
                        real au1g2 = (1 - ti) * (- norm1[2 * ii] * norm1[2 * ii + 1]); // a_{u1}(g2)
                        
                        real au2g1 = (1 - ti) * (- norm1[2 * ii + 1] * norm1[2 * ii]); // a_{u2}(g1)
                        real au2g2 = (1 - ti) * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]); // a_{u2}(g2)
                        
                        real au3g1 = ti * (1. - norm1[2 * ii] * norm1[2 * ii]); // a_{u3}(g1)
                        real au3g2 = ti * (- norm1[2 * ii] * norm1[2 * ii + 1]); // a_{u3}(g2)
                        
                        real au4g1 = ti * (- norm1[2 * ii + 1] * norm1[2 * ii]); // a_{u4}(g1)
                        real au4g2 = ti * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]); // a_{u4}(g2)
                        
                        real ag1f = axPhiEpsilon((uxi - uprx) * (1. - norm1[2 * ii] * norm1[2 * ii]) - (uyi - upry) * norm1[2 * ii + 1] * norm1[2 * ii], - (uxi - uprx) * norm1[2 * ii] * norm1[2 * ii + 1] + (uyi - upry) * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]), epsphi); // a_{g1}(f)°(g1,g2)
                        real ag2f = ayPhiEpsilon((uxi - uprx) * (1. - norm1[2 * ii] * norm1[2 * ii]) - (uyi - upry) * norm1[2 * ii + 1] * norm1[2 * ii], - (uxi - uprx) * norm1[2 * ii] * norm1[2 * ii + 1] + (uyi - upry) * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]), epsphi); // a_{g2}(f)°(g1,g2)
                        
                        idWW(dofx0) += - mucol * s[ii] * (ag1f * au1g1 + ag2f * au1g2) * wi * Li; // a_{dofx0}(\int_{gamma_{c}} (-mu*s*phi_{epsilon}...) )
                        idWW(dofx0 + 1) += - mucol * s[ii] * (ag1f * au2g1 + ag2f * au2g2) * wi * Li; // a_{dofx0+1}(\int_{gamma_{c}} (-mu*s*phi_{epsilon}...) )
                        idWW(dofx1) += - mucol * s[ii] * (ag1f * au3g1 + ag2f * au3g2) * wi * Li; // a_{dofx1}(\int_{gamma_{c}} (-mu*s*phi_{epsilon}...) )
                        idWW(dofx1 + 1) += - mucol * s[ii] * (ag1f * au4g1 + ag2f * au4g2) * wi * Li; // a_{dofx1+1}(\int_{gamma_{c}} (-mu*s*phi_{epsilon}...) )
                        
                        // Projected point derivative
                        au1g1 = - ph1 * (1. - norm1[2 * ii] * norm1[2 * ii]); // a_{u1}(g1)
                        au1g2 = - ph1 * (- norm1[2 * ii] * norm1[2 * ii + 1]); // a_{u1}(g2)
                        
                        au2g1 = - ph1 * (- norm1[2 * ii + 1] * norm1[2 * ii]); // a_{u2}(g1)
                        au2g2 = - ph1 * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]); // a_{u2}(g2)
                        
                        au3g1 = - ph2 * (1. - norm1[2 * ii] * norm1[2 * ii]); // a_{u3}(g1)
                        au3g2 = - ph2 * (- norm1[2 * ii] * norm1[2 * ii + 1]); // a_{u3}(g2)
                        
                        au4g1 = - ph2 * (- norm1[2 * ii + 1] * norm1[2 * ii]); // a_{u4}(g1)
                        au4g2 = - ph2 * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]); // a_{u4}(g2)
                        
                        idWW(ndof1 + dofp1) += - mucol * s[ii] * (ag1f * au1g1 + ag2f * au1g2) * wi * Li; // a_{dofx0}(\int_{gamma_{c}} (-mu*s*phi_{epsilon}...) )
                        idWW(ndof1 + dofp1 + 1) += - mucol * s[ii] * (ag1f * au2g1 + ag2f * au2g2) * wi * Li; // a_{dofx0+1}(\int_{gamma_{c}} (-mu*s*phi_{epsilon}...) )
                        idWW(ndof1 + dofp2) += - mucol * s[ii] * (ag1f * au3g1 + ag2f * au3g2) * wi * Li; // a_{dofx1}(\int_{gamma_{c}} (-mu*s*phi_{epsilon}...) )
                        idWW(ndof1 + dofp2 + 1) += - mucol * s[ii] * (ag1f * au4g1 + ag2f * au4g2) * wi * Li; // a_{dofx1+1}(\int_{gamma_{c}} (-mu*s*phi_{epsilon}...) )
                        
                    }
<% } else { -%>
                    int idseg = contactElements[i]; // Triangle in contact id (0,...,ntri1)
                    int trid1 = triid1[idseg]; // Tri ID w.r.t to the whole border (0,...,Mesh0.nbe)
                    for (int k = 0; k < 3; k++) { ABT10[k] = xbU1[tridof1[3 * trid1] + k]; }
                    // coord of the first node of the triangle with id="trid1"
                    for (int k = 0; k < 3; k++) { ABT10[k + 3] = xbU1[tridof1[3 * trid1 + 1] + k]; }
                    // coord of the second node of the triangle with id="trid1"
                    for (int k = 0; k < 3; k++) { ABT10[k + 6] = xbU1[tridof1[3 * trid1 + 2] + k]; }
                    // coord of the third node of the triangle with id="trid1"
                    PO1 = ABT10(0 : 2); // First point of the triangle
                    PO2 = ABT10(3 : 5); // Second point of the triangle
                    PO3 = ABT10(6 : 8); // Third point of the triangle
                    ve1 = PO2 - PO1;
                    ve2 = PO3 - PO1;
                    provec = vectorProduct(ve1, ve2); // Vectorial product in order to compute the area of the triangle (previous iteration) where the integration is done
                    Si = (provec[0]^2 + provec[1]^2 + provec[2]^2)^0.5; // = 2* The surface of the (previous iteration) triangle where the integration is done (contact area 1), correspond to variable changes in the surface integral
                    
                    for (int j = 0; j < integrationPointsNumber; j++) {
                        // loop on ip points
                        int ii = j + idseg * integrationPointsNumber;
                        real ti1 = integrationPointsPositions1[j]; // the parameter of the ip point in the triangle (integration rule)
                        real ti2 = integrationPointsPositions2[j];
                        real wi = integrationPointsWeights[j]; // weight integration rule
                        
                        for (int k = 0; k < 3; k++) { AB[k] = X1[tridof1[3 * trid1] + k]; }
                        // u of the first node of the triangle with id="trid1"
                        for (int k = 0; k < 3; k++) { AB[k + 3] = X1[tridof1[3 * trid1 + 1] + k]; }
                        // u of the second node of the triangle with id="trid1"
                        for (int k = 0; k < 3; k++) { AB[k + 6] = X1[tridof1[3 * trid1 + 2] + k]; }
                        // u of the third node of the triangle with id="trid1"
                        
                        real[int] P1X = P1Function(AB, ti1, ti2); // The coordinates of the ip points
                        real ux = P1X[0]; // x
                        real uy = P1X[1]; // y
                        real uz = P1X[2]; // z
                        
                        // projection here
                        real et1 = eta[2 * ii]; // eta1 parameter of the triangle
                        real et2 = eta[2 * ii + 1]; // eta2 parameter of the triangle
                        int trid2 = tid1[ii]; // Triangle id \in contact area 2 closest to the integration point
                        
                        for (int k = 0; k < 3; k++) { AB[k] = X2[tridof2[3 * trid2] + k]; }
                        // coord of the first node of the triangle with id="trid2"
                        for (int k = 0; k < 3; k++) { AB[k + 3] = X2[tridof2[3 * trid2 + 1] + k]; }
                        // coord of the second node of the triangle with id="trid2"
                        for (int k = 0; k < 3; k++) { AB[k + 6] = X2[tridof2[3 * trid2 + 2] + k]; }
                        // coord of the third node of the triangle with id="trid2"
                        P1X = P1Function(AB, et1, et2); // The coordinates of the ip points
                        real uxpr = P1X[0]; // x of the projected point on the surface 2 for the ip points at the contact area 1
                        real uypr = P1X[1]; // y of the projected point on the surface 2 for the ip points at the contact area 1
                        real uzpr = P1X[2]; // z of the projected point on the surface 2 for the ip points at the contact area 1
                        
                        // phiEpsilon(,)= f(.,.) ° (g1,g2,g3) => a_{u1}(f)= a_{g1}(f)°(g1,g2,g3) * a_{u1}(g1) +a_{g2}(f)°(g1,g2,g3) * a_{u2}(g2)+ a_{g3}(f)°(g1,g2,g3) * a_{u3}(g3)
                        
                        real[int, int] Pt(3, 3); // Matrix to give the tangential part of a vector
                        Pt = [[1. - norm1[3 * ii] * norm1[3 * ii], - norm1[3 * ii] * norm1[3 * ii + 1], - norm1[3 * ii] * norm1[3 * ii + 2]],
                            [- norm1[3 * ii] * norm1[3 * ii + 1], 1. - norm1[3 * ii + 1] * norm1[3 * ii + 1], - norm1[3 * ii + 1] * norm1[3 * ii + 2]],
                            [- norm1[3 * ii] * norm1[3 * ii + 2], - norm1[3 * ii + 1] * norm1[3 * ii + 2], 1. - norm1[3 * ii + 2] * norm1[3 * ii + 2]]];
                        real[int] urt(3); // relative tangential displacement vector
                        urt = [ux - uxpr, uy - uypr, uz - uzpr];
                        urt = Pt * urt;
                        
                        real ag1f = axPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g1}(f)°(g1,g2,g3)
                        real ag2f = ayPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g2}(f)°(g1,g2,g3)
                        real ag3f = azPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g3}(f)°(g1,g2,g3)
                        
                        // degree of freedom of (x_vertice1, y_vertice1, z_vertice1, x_vertice2, y_vertice2, z_vertice2, ... ) of the triangle
                        int[int] df1 = [tridof1[3 * trid1], tridof1[3 * trid1] + 1, tridof1[3 * trid1] + 2, tridof1[3 * trid1 + 1], tridof1[3 * trid1 + 1] + 1, tridof1[3 * trid1 + 1] + 2, tridof1[3 * trid1 + 2], tridof1[3 * trid1 + 2] + 1, tridof1[3 * trid1 + 2] + 2]; // dof of the triangle three points where the integration point belongs (contact area 1)
                        int[int] df2 = [tridof2[3 * trid2], tridof2[3 * trid2] + 1, tridof2[3 * trid2] + 2, tridof2[3 * trid2 + 1], tridof2[3 * trid2 + 1] + 1, tridof2[3 * trid2 + 1] + 2, tridof2[3 * trid2 + 2], tridof2[3 * trid2 + 2] + 1, tridof2[3 * trid2 + 2] + 2]; // dof of the triangle three points where the integration point projection belongs (contact area 2)
                        real[int] phit1 = [phi1(ti1, ti2), phi1(ti1, ti2), phi1(ti1, ti2), phi2(ti1, ti2), phi2(ti1, ti2), phi2(ti1, ti2), phi3(ti1, ti2), phi3(ti1, ti2), phi3(ti1, ti2)]; // Shape functions
                        real[int] phit2 = [phi1(et1, et2), phi1(et1, et2), phi1(et1, et2), phi2(et1, et2), phi2(et1, et2), phi2(et1, et2), phi3(et1, et2), phi3(et1, et2), phi3(et1, et2)];
                        real[int] pt1 = [1. - norm1[3 * ii] * norm1[3 * ii], - norm1[3 * ii] * norm1[3 * ii + 1], - norm1[3 * ii] * norm1[3 * ii + 2], 1. - norm1[3 * ii] * norm1[3 * ii], - norm1[3 * ii] * norm1[3 * ii + 1], - norm1[3 * ii] * norm1[3 * ii + 2], 1. - norm1[3 * ii] * norm1[3 * ii], - norm1[3 * ii] * norm1[3 * ii + 1], - norm1[3 * ii] * norm1[3 * ii + 2]];
                        real[int] pt2 = [- norm1[3 * ii] * norm1[3 * ii + 1], 1. - norm1[3 * ii + 1] * norm1[3 * ii + 1], - norm1[3 * ii + 1] * norm1[3 * ii + 2], - norm1[3 * ii] * norm1[3 * ii + 1], 1. - norm1[3 * ii + 1] * norm1[3 * ii + 1], - norm1[3 * ii + 1] * norm1[3 * ii + 2], - norm1[3 * ii] * norm1[3 * ii + 1], 1. - norm1[3 * ii + 1] * norm1[3 * ii + 1], - norm1[3 * ii + 1] * norm1[3 * ii + 2]];
                        real[int] pt3 = [- norm1[3 * ii] * norm1[3 * ii + 2], - norm1[3 * ii + 1] * norm1[3 * ii + 2], 1. - norm1[3 * ii + 2] * norm1[3 * ii + 2], - norm1[3 * ii] * norm1[3 * ii + 2], - norm1[3 * ii + 1] * norm1[3 * ii + 2], 1. - norm1[3 * ii + 2] * norm1[3 * ii + 2], - norm1[3 * ii] * norm1[3 * ii + 2], - norm1[3 * ii + 1] * norm1[3 * ii + 2], 1. - norm1[3 * ii + 2] * norm1[3 * ii + 2]];
                        
                        real[int] aug1(9), aug2(9), aug3(9), aug1p(9), aug2p(9), aug3p(9);
                        for (int k = 0; k < 9; k++) {
                            aug1[k] = pt1[k] * phit1[k];
                            aug2[k] = pt2[k] * phit1[k];
                            aug3[k] = pt3[k] * phit1[k];
                            aug1p[k] = - pt1[k] * phit2[k];
                            aug2p[k] = - pt2[k] * phit2[k];
                            aug3p[k] = - pt3[k] * phit2[k];
                        }
                        
                        for (int k = 0; k < 9; k++) {
                            idWW(df1[k]) += - mucol * s[ii] * (ag1f * aug1[k] + ag2f * aug2[k] + ag3f * aug3[k]) * wi * Si;
                            idWW(ndof1 + df2[k]) += - mucol * s[ii] * (ag1f * aug1p[k] + ag2f * aug2p[k] + ag3f * aug3p[k]) * wi * Si;
                        }
                    }
<% } -%>
                }
            }
            
            return idWW;
        }
        
        // The energy Hessian
        matrix iddWW;
        func matrix iddW(real[int] &D) {
            matrix iddW1; // Energy Hessian for body 1
            matrix iddW2; // Energy Hessian for body 2
            matrix iddW3; // 
            matrix iddW4; // 
            iddW3.resize(ndof1, ndof2);
            iddW4.resize(ndof2, ndof1);
            iddW1.resize(ndof1, ndof1);
            iddW2.resize(ndof2, ndof2);
            
            Wh1<%- interfunc1 -%>; // [D1x, D1y] if dim=2 and [D1x, D1y, D1z] if dim=3
            D1x[] = D(0 : (ndof1 - 1));
            Wh2<%- interfunc2 -%>; // [D2x, D2y] if dim=2 and [D2x, D2y, D2z] if dim=3
            D2x[] = D(ndof1 : (ndoft - 1));
            
            varf ddWW1(<%- testfunc2 -%>, <%- testfunc1 -%>)
                = intN(Mesh0)(ddW2d0(<%- interfunc1 -%>, <%- testfunc2 -%>, <%- testfunc1 -%>));
            iddW1 = ddWW1(Wh1, Wh1);
            
            varf ddWW2(<%- testfunc2 -%>, <%- testfunc1 -%>)
                = intN(Mesh1)(ddW2d1(<%- interfunc2 -%>, <%- testfunc2 -%>, <%- testfunc1 -%>));
            iddW2 = ddWW2(Wh2, Wh2);
            
            real[int] X1(ndof1);
            real[int] X2(ndof1 : (ndoft - 1));
            X1 = D(0 : (ndof1 - 1));
            X2 = D(ndof1 : (ndoft - 1));
            // For quasi-static friction
            real[int] Xn1(ndof1);
            real[int] Xn2(ndof1 : (ndoft - 1));
            Xn1 = D1x1[]; // = U of the previous increment n
            Xn2 = D2x2[]; // = U of the previous increment n
            X1 -= Xn1; // = Un+1 -Un
            X2 -= Xn2; // = Un+1 -Un on the contact area of the second body
            // //////////////////////////
            
            if (tresca) {
                // the normal pressure is now computed
<% if (dimension === 2){ -%>
                real Li;
<% } -%>
<% if (dimension !== 2){ -%>
                real[int] ABT10(9), ve1(3), ve2(3), provec(3);
                real Si;
<% } -%>
                for (int i = 0; i < nContactElements; i++) {
                    // Loop on the segment/triangle in contact
<% if (dimension === 2){ -%>
                    int idseg = contactElements[i]; // Segment id in 0,...nseg1
                    int seid1 = segid1[idseg]; // Seg ID w.r.t to the whole border
                    int dofx0 = segdof1[2 * seid1]; // dof x of the first vertice of the segment
                    int dofx1 = segdof1[2 * seid1 + 1]; // dof x of the secondt vertice of the segment
                    // Integral on the surface of the previous iteration where there is a contact => Fixed point for the Tresca problem
                    Li = ((xbU1[dofx1] - xbU1[dofx0])^2 + (xbU1[dofx1 + 1] - xbU1[dofx0 + 1])^2)^0.5; // Length due to the integral by substitution
                    for (int j = 0; j < integrationPointsNumber; j++) {
                        // shape function of the first segment
                        int ii = j + idseg * integrationPointsNumber;
                        
                        real tt = eta[ii];
                        real ph1 = 1 - tt;
                        real ph2 = tt;
                        
                        int posi = pos[ii]; // The segment number w.r.t to the whole border of the closest segment
                        int dofp1 = segdof2[2 * posi]; // Dof x of the first vertice of the segment
                        int dofp2 = segdof2[2 * posi + 1]; // Dof x of the second vertice of the segment
                        AB[0] = X2[dofp1];
                        AB[1] = X2[dofp1 + 1];
                        AB[2] = X2[dofp2];
                        AB[3] = X2[dofp2 + 1];
                        real[int] P1X1 = P1Function(AB, tt); // Segment [x0,x1] => the closest point of (xp,yp) to the segment
                        real uprx = P1X1[0]; // The projected points on the contact area 2
                        real upry = P1X1[1];
                        
                        real ti = integrationPointsPositions[j]; // the parameter of the ip point in the segment (integration rule)
                        real wi = integrationPointsWeights[j]; // weight integration rule
                        real uxi = intpip(ti, X1[dofx0], X1[dofx1]); // displacement x of the ip points
                        real uyi = intpip(ti, X1[dofx0 + 1], X1[dofx1 + 1]); // displacement y of the ip points
                        
                        // phiEpsilon(,)= f(.,.) ° (g1,g2) => a_{u1}(f)= a_{g1}(f)°(g1,g2) * a_{u1}(g1) + a_{g2}(f)°(g1,g2) * a_{u2}(g2)
                        real au1g1 = (1 - ti) * (1. - norm1[2 * ii] * norm1[2 * ii]); // a_{u1}(g1)
                        real au1g2 = (1 - ti) * (- norm1[2 * ii] * norm1[2 * ii + 1]); // a_{u1}(g2)
                        
                        real au2g1 = (1 - ti) * (- norm1[2 * ii + 1] * norm1[2 * ii]); // a_{u2}(g1)
                        real au2g2 = (1 - ti) * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]); // a_{u2}(g2)
                        
                        real au3g1 = ti * (1. - norm1[2 * ii] * norm1[2 * ii]); // a_{u3}(g1)
                        real au3g2 = ti * (- norm1[2 * ii] * norm1[2 * ii + 1]); // a_{u3}(g2)
                        
                        real au4g1 = ti * (- norm1[2 * ii + 1] * norm1[2 * ii]); // a_{u4}(g1)
                        real au4g2 = ti * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]); // a_{u4}(g2)
                        
                        real ag1f = axPhiEpsilon((uxi - uprx) * (1. - norm1[2 * ii] * norm1[2 * ii]) - (uyi - upry) * norm1[2 * ii + 1] * norm1[2 * ii], - (uxi - uprx) * norm1[2 * ii] * norm1[2 * ii + 1] + (uyi - upry) * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]), epsphi); // a_{g1}(f)°(g1,g2)
                        real ag2f = ayPhiEpsilon((uxi - uprx) * (1. - norm1[2 * ii] * norm1[2 * ii]) - (uyi - upry) * norm1[2 * ii + 1] * norm1[2 * ii], - (uxi - uprx) * norm1[2 * ii] * norm1[2 * ii + 1] + (uyi - upry) * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]), epsphi); // a_{g2}(f)°(g1,g2)
                        
                        real ag11f = axxPhiEpsilon((uxi - uprx) * (1. - norm1[2 * ii] * norm1[2 * ii]) - (uyi - upry) * norm1[2 * ii + 1] * norm1[2 * ii], - (uxi - uprx) * norm1[2 * ii] * norm1[2 * ii + 1] + (uyi - upry) * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]), epsphi); // a_{g1g1}(f)°(g1,g2)
                        real ag12f = axyPhiEpsilon((uxi - uprx) * (1. - norm1[2 * ii] * norm1[2 * ii]) - (uyi - upry) * norm1[2 * ii + 1] * norm1[2 * ii], - (uxi - uprx) * norm1[2 * ii] * norm1[2 * ii + 1] + (uyi - upry) * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]), epsphi); // a_{g1g2}(f)°(g1,g2)
                        real ag21f = axyPhiEpsilon((uxi - uprx) * (1. - norm1[2 * ii] * norm1[2 * ii]) - (uyi - upry) * norm1[2 * ii + 1] * norm1[2 * ii], - (uxi - uprx) * norm1[2 * ii] * norm1[2 * ii + 1] + (uyi - upry) * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]), epsphi); // a_{g2g1}(f)°(g1,g2)
                        real ag22f = ayyPhiEpsilon((uxi - uprx) * (1. - norm1[2 * ii] * norm1[2 * ii]) - (uyi - upry) * norm1[2 * ii + 1] * norm1[2 * ii], - (uxi - uprx) * norm1[2 * ii] * norm1[2 * ii + 1] + (uyi - upry) * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]), epsphi); // a_{g2g2}(f)°(g1,g2)
                        
                        real ax1ag1f = ag11f * au1g1 + ag12f * au1g2; // a_{x1}(ag1f)
                        real ax2ag1f = ag11f * au2g1 + ag12f * au2g2; // a_{x2}(ag1f)
                        real ax3ag1f = ag11f * au3g1 + ag12f * au3g2; // a_{x3}(ag1f)
                        real ax4ag1f = ag11f * au4g1 + ag12f * au4g2; // a_{x4}(ag1f)
                        
                        real ax1ag2f = ag12f * au1g1 + ag22f * au1g2; // a_{x1}(ag2f)
                        real ax2ag2f = ag12f * au2g1 + ag22f * au2g2; // a_{x2}(ag2f)
                        real ax3ag2f = ag12f * au3g1 + ag22f * au3g2; // a_{x3}(ag2f)
                        real ax4ag2f = ag12f * au4g1 + ag22f * au4g2; // a_{x4}(ag2f)
                        
                        // idWW1(dofx0)+= -mucol*s[ii]* (ag1f*au1g1 + ag2f*au1g2) *wi*Li; // a_{dofx0}(\int_{gamma_{c}} (-mu*s*phi_{epsilon}...) )
                        iddW1(dofx0, dofx0) += - mucol * s[ii] * (ax1ag1f * au1g1 + ax1ag2f * au1g2) * wi * Li; // a_{x1x1}
                        iddW1(dofx0, dofx0 + 1) += - mucol * s[ii] * (ax2ag1f * au1g1 + ax2ag2f * au1g2) * wi * Li; // a_{x1x2}
                        iddW1(dofx0, dofx1) += - mucol * s[ii] * (ax3ag1f * au1g1 + ax3ag2f * au1g2) * wi * Li; // a_{x1x3}
                        iddW1(dofx0, dofx1 + 1) += - mucol * s[ii] * (ax4ag1f * au1g1 + ax4ag2f * au1g2) * wi * Li; // a_{x1x4}
                        
                        // idWW1(dofx0+1)+= -mucol*s[ii]* (ag1f*au2g1 + ag2f*au2g2) *wi*Li; // a_{dofx0+1}(\int_{gamma_{c}} (-mu*s*phi_{epsilon}...) )
                        iddW1(dofx0 + 1, dofx0) += - mucol * s[ii] * (ax1ag1f * au2g1 + ax1ag2f * au2g2) * wi * Li; // a_{x2x1}
                        iddW1(dofx0 + 1, dofx0 + 1) += - mucol * s[ii] * (ax2ag1f * au2g1 + ax2ag2f * au2g2) * wi * Li; // a_{x2x2}
                        iddW1(dofx0 + 1, dofx1) += - mucol * s[ii] * (ax3ag1f * au2g1 + ax3ag2f * au2g2) * wi * Li; // a_{x2x3}
                        iddW1(dofx0 + 1, dofx1 + 1) += - mucol * s[ii] * (ax4ag1f * au2g1 + ax4ag2f * au2g2) * wi * Li; // a_{x2x4}
                        
                        // idWW1(dofx1)+= -mucol*s[ii]* (ag1f*au3g1 + ag2f*au3g2) *wi*Li; // a_{dofx1}(\int_{gamma_{c}} (-mu*s*phi_{epsilon}...) )
                        iddW1(dofx1, dofx0) += - mucol * s[ii] * (ax1ag1f * au3g1 + ax1ag2f * au3g2) * wi * Li; // a_{x3x1}
                        iddW1(dofx1, dofx0 + 1) += - mucol * s[ii] * (ax2ag1f * au3g1 + ax2ag2f * au3g2) * wi * Li; // a_{x3x2}
                        iddW1(dofx1, dofx1) += - mucol * s[ii] * (ax3ag1f * au3g1 + ax3ag2f * au3g2) * wi * Li; // a_{x3x3}
                        iddW1(dofx1, dofx1 + 1) += - mucol * s[ii] * (ax4ag1f * au3g1 + ax4ag2f * au3g2) * wi * Li; // a_{x3x4}
                        
                        // idWW1(dofx1+1)+= -mucol*s[ii]* (ag1f*au4g1 + ag2f*au4g2) *wi*Li; // a_{dofx1+1}(\int_{gamma_{c}} (-mu*s*phi_{epsilon}...) )
                        iddW1(dofx1 + 1, dofx0) += - mucol * s[ii] * (ax1ag1f * au4g1 + ax1ag2f * au4g2) * wi * Li; // a_{x4x1}
                        iddW1(dofx1 + 1, dofx0 + 1) += - mucol * s[ii] * (ax2ag1f * au4g1 + ax2ag2f * au4g2) * wi * Li; // a_{x4x2}
                        iddW1(dofx1 + 1, dofx1) += - mucol * s[ii] * (ax3ag1f * au4g1 + ax3ag2f * au4g2) * wi * Li; // a_{x4x3}
                        iddW1(dofx1 + 1, dofx1 + 1) += - mucol * s[ii] * (ax4ag1f * au4g1 + ax4ag2f * au4g2) * wi * Li; // a_{x4x4}
                        
                        // iddw3: Derivatives wrt u and its project
                        
                        // Projected point derivative
                        real au1g13 = - ph1 * (1. - norm1[2 * ii] * norm1[2 * ii]); // a_{u1}(g1)
                        real au1g23 = - ph1 * (- norm1[2 * ii] * norm1[2 * ii + 1]); // a_{u1}(g2)
                        
                        real au2g13 = - ph1 * (- norm1[2 * ii + 1] * norm1[2 * ii]); // a_{u2}(g1)
                        real au2g23 = - ph1 * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]); // a_{u2}(g2)
                        
                        real au3g13 = - ph2 * (1. - norm1[2 * ii] * norm1[2 * ii]); // a_{u3}(g1)
                        real au3g23 = - ph2 * (- norm1[2 * ii] * norm1[2 * ii + 1]); // a_{u3}(g2)
                        
                        real au4g13 = - ph2 * (- norm1[2 * ii + 1] * norm1[2 * ii]); // a_{u4}(g1)
                        real au4g23 = - ph2 * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]); // a_{u4}(g2)
                        
                        ax1ag1f = ag11f * au1g13 + ag12f * au1g23; // a_{x1}(ag1f)
                        ax2ag1f = ag11f * au2g13 + ag12f * au2g23; // a_{x2}(ag1f)
                        ax3ag1f = ag11f * au3g13 + ag12f * au3g23; // a_{x3}(ag1f)
                        ax4ag1f = ag11f * au4g13 + ag12f * au4g23; // a_{x4}(ag1f)
                        
                        ax1ag2f = ag12f * au1g13 + ag22f * au1g23; // a_{x1}(ag2f)
                        ax2ag2f = ag12f * au2g13 + ag22f * au2g23; // a_{x2}(ag2f)
                        ax3ag2f = ag12f * au3g13 + ag22f * au3g23; // a_{x3}(ag2f)
                        ax4ag2f = ag12f * au4g13 + ag22f * au4g23; // a_{x4}(ag2f)
                        
                        // idWW1(dofx0)+= -mucol*s[ii]* (ag1f*au1g1 + ag2f*au1g2) *wi*Li; // a_{dofx0}(\int_{gamma_{c}} (-mu*s*phi_{epsilon}...) )
                        iddW3(dofx0, dofp1) += - mucol * s[ii] * (ax1ag1f * au1g1 + ax1ag2f * au1g2) * wi * Li; // a_{x1x1}
                        iddW3(dofx0, dofp1 + 1) += - mucol * s[ii] * (ax2ag1f * au1g1 + ax2ag2f * au1g2) * wi * Li; // a_{x1x2}
                        iddW3(dofx0, dofp2) += - mucol * s[ii] * (ax3ag1f * au1g1 + ax3ag2f * au1g2) * wi * Li; // a_{x1x3}
                        iddW3(dofx0, dofp2 + 1) += - mucol * s[ii] * (ax4ag1f * au1g1 + ax4ag2f * au1g2) * wi * Li; // a_{x1x4}
                        
                        iddW3(dofx0 + 1, dofp1) += - mucol * s[ii] * (ax1ag1f * au2g1 + ax1ag2f * au2g2) * wi * Li; // a_{x2x1}
                        iddW3(dofx0 + 1, dofp1 + 1) += - mucol * s[ii] * (ax2ag1f * au2g1 + ax2ag2f * au2g2) * wi * Li; // a_{x2x2}
                        iddW3(dofx0 + 1, dofp2) += - mucol * s[ii] * (ax3ag1f * au2g1 + ax3ag2f * au2g2) * wi * Li; // a_{x2x3}
                        iddW3(dofx0 + 1, dofp2 + 1) += - mucol * s[ii] * (ax4ag1f * au2g1 + ax4ag2f * au2g2) * wi * Li; // a_{x2x4}
                        
                        iddW3(dofx1, dofp1) += - mucol * s[ii] * (ax1ag1f * au3g1 + ax1ag2f * au3g2) * wi * Li; // a_{x3x1}
                        iddW3(dofx1, dofp1 + 1) += - mucol * s[ii] * (ax2ag1f * au3g1 + ax2ag2f * au3g2) * wi * Li; // a_{x3x2}
                        iddW3(dofx1, dofp2) += - mucol * s[ii] * (ax3ag1f * au3g1 + ax3ag2f * au3g2) * wi * Li; // a_{x3x3}
                        iddW3(dofx1, dofp2 + 1) += - mucol * s[ii] * (ax4ag1f * au3g1 + ax4ag2f * au3g2) * wi * Li; // a_{x3x4}
                        
                        iddW3(dofx1 + 1, dofp1) += - mucol * s[ii] * (ax1ag1f * au4g1 + ax1ag2f * au4g2) * wi * Li; // a_{x4x1}
                        iddW3(dofx1 + 1, dofp1 + 1) += - mucol * s[ii] * (ax2ag1f * au4g1 + ax2ag2f * au4g2) * wi * Li; // a_{x4x2}
                        iddW3(dofx1 + 1, dofp2) += - mucol * s[ii] * (ax3ag1f * au4g1 + ax3ag2f * au4g2) * wi * Li; // a_{x4x3}
                        iddW3(dofx1 + 1, dofp2 + 1) += - mucol * s[ii] * (ax4ag1f * au4g1 + ax4ag2f * au4g2) * wi * Li; // a_{x4x4}
                        
                        // iddw2: Projected point derivative
                        au1g1 = - ph1 * (1. - norm1[2 * ii] * norm1[2 * ii]); // a_{u1}(g1)
                        au1g2 = - ph1 * (- norm1[2 * ii] * norm1[2 * ii + 1]); // a_{u1}(g2)
                        
                        au2g1 = - ph1 * (- norm1[2 * ii + 1] * norm1[2 * ii]); // a_{u2}(g1)
                        au2g2 = - ph1 * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]); // a_{u2}(g2)
                        
                        au3g1 = - ph2 * (1. - norm1[2 * ii] * norm1[2 * ii]); // a_{u3}(g1)
                        au3g2 = - ph2 * (- norm1[2 * ii] * norm1[2 * ii + 1]); // a_{u3}(g2)
                        
                        au4g1 = - ph2 * (- norm1[2 * ii + 1] * norm1[2 * ii]); // a_{u4}(g1)
                        au4g2 = - ph2 * (1. - norm1[2 * ii + 1] * norm1[2 * ii + 1]); // a_{u4}(g2)
                        
                        ax1ag1f = ag11f * au1g1 + ag12f * au1g2; // a_{x1}(ag1f)
                        ax2ag1f = ag11f * au2g1 + ag12f * au2g2; // a_{x2}(ag1f)
                        ax3ag1f = ag11f * au3g1 + ag12f * au3g2; // a_{x3}(ag1f)
                        ax4ag1f = ag11f * au4g1 + ag12f * au4g2; // a_{x4}(ag1f)
                        
                        ax1ag2f = ag12f * au1g1 + ag22f * au1g2; // a_{x1}(ag2f)
                        ax2ag2f = ag12f * au2g1 + ag22f * au2g2; // a_{x2}(ag2f)
                        ax3ag2f = ag12f * au3g1 + ag22f * au3g2; // a_{x3}(ag2f)
                        ax4ag2f = ag12f * au4g1 + ag22f * au4g2; // a_{x4}(ag2f)
                        
                        // idWW2(dofp1)+= -mucol*s[ii]* (ag1f*au1g1 + ag2f*au1g2) *wi*Li;
                        iddW2(dofp1, dofp1) += - mucol * s[ii] * (ax1ag1f * au1g1 + ax1ag2f * au1g2) * wi * Li; // a_{x1x1}
                        iddW2(dofp1, dofp1 + 1) += - mucol * s[ii] * (ax2ag1f * au1g1 + ax2ag2f * au1g2) * wi * Li; // a_{x1x2}
                        iddW2(dofp1, dofp2) += - mucol * s[ii] * (ax3ag1f * au1g1 + ax3ag2f * au1g2) * wi * Li; // a_{x1x3}
                        iddW2(dofp1, dofp2 + 1) += - mucol * s[ii] * (ax4ag1f * au1g1 + ax4ag2f * au1g2) * wi * Li; // a_{x1x4}
                        
                        iddW2(dofp1 + 1, dofp1) += - mucol * s[ii] * (ax1ag1f * au2g1 + ax1ag2f * au2g2) * wi * Li; // a_{x2x1}
                        iddW2(dofp1 + 1, dofp1 + 1) += - mucol * s[ii] * (ax2ag1f * au2g1 + ax2ag2f * au2g2) * wi * Li; // a_{x2x2}
                        iddW2(dofp1 + 1, dofp2) += - mucol * s[ii] * (ax3ag1f * au2g1 + ax3ag2f * au2g2) * wi * Li; // a_{x2x3}
                        iddW2(dofp1 + 1, dofp2 + 1) += - mucol * s[ii] * (ax4ag1f * au2g1 + ax4ag2f * au2g2) * wi * Li; // a_{x2x4}
                        
                        iddW2(dofp2, dofp1) += - mucol * s[ii] * (ax1ag1f * au3g1 + ax1ag2f * au3g2) * wi * Li; // a_{x3x1}
                        iddW2(dofp2, dofp1 + 1) += - mucol * s[ii] * (ax2ag1f * au3g1 + ax2ag2f * au3g2) * wi * Li; // a_{x3x2}
                        iddW2(dofp2, dofp2) += - mucol * s[ii] * (ax3ag1f * au3g1 + ax3ag2f * au3g2) * wi * Li; // a_{x3x3}
                        iddW2(dofp2, dofp2 + 1) += - mucol * s[ii] * (ax4ag1f * au3g1 + ax4ag2f * au3g2) * wi * Li; // a_{x3x4}
                        
                        iddW2(dofp2 + 1, dofp1) += - mucol * s[ii] * (ax1ag1f * au4g1 + ax1ag2f * au4g2) * wi * Li; // a_{x4x1}
                        iddW2(dofp2 + 1, dofp1 + 1) += - mucol * s[ii] * (ax2ag1f * au4g1 + ax2ag2f * au4g2) * wi * Li; // a_{x4x2}
                        iddW2(dofp2 + 1, dofp2) += - mucol * s[ii] * (ax3ag1f * au4g1 + ax3ag2f * au4g2) * wi * Li; // a_{x4x3}
                        iddW2(dofp2 + 1, dofp2 + 1) += - mucol * s[ii] * (ax4ag1f * au4g1 + ax4ag2f * au4g2) * wi * Li; // a_{x4x4}
                        
                    }
<% } else { -%>
                    int idseg = contactElements[i]; // Triangle in contact id (0,...,ntri1)
                    int trid1 = triid1[idseg]; // Tri ID w.r.t to the whole border (0,...,Mesh0.nbe)
                    for (int k = 0; k < 3; k++) { ABT10[k] = xbU1[tridof1[3 * trid1] + k]; }
                    // coord of the first node of the triangle with id="trid1"
                    for (int k = 0; k < 3; k++) { ABT10[k + 3] = xbU1[tridof1[3 * trid1 + 1] + k]; }
                    // coord of the second node of the triangle with id="trid1"
                    for (int k = 0; k < 3; k++) { ABT10[k + 6] = xbU1[tridof1[3 * trid1 + 2] + k]; }
                    // coord of the third node of the triangle with id="trid1"
                    PO1 = ABT10(0 : 2); // First point of the triangle
                    PO2 = ABT10(3 : 5); // Second point of the triangle
                    PO3 = ABT10(6 : 8); // Third point of the triangle
                    ve1 = PO2 - PO1;
                    ve2 = PO3 - PO1;
                    provec = vectorProduct(ve1, ve2); // Vectorial product in order to compute the area of the triangle (previous iteration) where the integration is done
                    Si = (provec[0]^2 + provec[1]^2 + provec[2]^2)^0.5; // = 2* The surface of the (previous iteration) triangle where the integration is done (contact area 1), correspond to variable changes in the surface integral
                    
                    for (int j = 0; j < integrationPointsNumber; j++) {
                        // loop on ip points
                        int ii = j + idseg * integrationPointsNumber;
                        real ti1 = integrationPointsPositions1[j]; // the parameter of the ip point in the triangle (integration rule)
                        real ti2 = integrationPointsPositions2[j];
                        real wi = integrationPointsWeights[j]; // weight integration rule
                        
                        for (int k = 0; k < 3; k++) { AB[k] = X1[tridof1[3 * trid1] + k]; }
                        // u of the first node of the triangle with id="trid1"
                        for (int k = 0; k < 3; k++) { AB[k + 3] = X1[tridof1[3 * trid1 + 1] + k]; }
                        // u of the second node of the triangle with id="trid1"
                        for (int k = 0; k < 3; k++) { AB[k + 6] = X1[tridof1[3 * trid1 + 2] + k]; }
                        // u of the third node of the triangle with id="trid1"
                        
                        real[int] P1X = P1Function(AB, ti1, ti2); // The coordinates of the ip points
                        real ux = P1X[0]; // x
                        real uy = P1X[1]; // y
                        real uz = P1X[2]; // z
                        
                        // projection here
                        real et1 = eta[2 * ii]; // eta1 parameter of the triangle
                        real et2 = eta[2 * ii + 1]; // eta2 parameter of the triangle
                        int trid2 = tid1[ii]; // Triangle id \in contact area 2 closest to the integration point
                        
                        for (int k = 0; k < 3; k++) { AB[k] = X2[tridof2[3 * trid2] + k]; }
                        // coord of the first node of the triangle with id="trid2"
                        for (int k = 0; k < 3; k++) { AB[k + 3] = X2[tridof2[3 * trid2 + 1] + k]; }
                        // coord of the second node of the triangle with id="trid2"
                        for (int k = 0; k < 3; k++) { AB[k + 6] = X2[tridof2[3 * trid2 + 2] + k]; }
                        // coord of the third node of the triangle with id="trid2"
                        P1X = P1Function(AB, et1, et2); // The coordinates of the ip points
                        real uxpr = P1X[0]; // x of the projected point on the surface 2 for the ip points at the contact area 1
                        real uypr = P1X[1]; // y of the projected point on the surface 2 for the ip points at the contact area 1
                        real uzpr = P1X[2]; // z of the projected point on the surface 2 for the ip points at the contact area 1
                        
                        // phiEpsilon(,)= f(.,.) ° (g1,g2,g3) => a_{u1}(f)= a_{g1}(f)°(g1,g2,g3) * a_{u1}(g1) +a_{g2}(f)°(g1,g2,g3) * a_{u2}(g2)+ a_{g3}(f)°(g1,g2,g3) * a_{u3}(g3)
                        
                        real[int, int] Pt(3, 3); // Matrix to give the tangential part of a vector
                        Pt = [[1. - norm1[3 * ii] * norm1[3 * ii], - norm1[3 * ii] * norm1[3 * ii + 1], - norm1[3 * ii] * norm1[3 * ii + 2]],
                            [- norm1[3 * ii] * norm1[3 * ii + 1], 1. - norm1[3 * ii + 1] * norm1[3 * ii + 1], - norm1[3 * ii + 1] * norm1[3 * ii + 2]],
                            [- norm1[3 * ii] * norm1[3 * ii + 2], - norm1[3 * ii + 1] * norm1[3 * ii + 2], 1. - norm1[3 * ii + 2] * norm1[3 * ii + 2]]];
                        real[int] urt(3); // relative tangential displacement vector
                        urt = [ux - uxpr, uy - uypr, uz - uzpr];
                        urt = Pt * urt;
                        
                        real ag1f = axPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g1}(f)°(g1,g2,g3)
                        real ag2f = ayPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g2}(f)°(g1,g2,g3)
                        real ag3f = azPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g3}(f)°(g1,g2,g3)
                        
                        // degree of freedom of (x_vertice1, y_vertice1, z_vertice1, x_vertice2, y_vertice2, z_vertice2, ... ) of the triangle
                        int[int] df1 = [tridof1[3 * trid1], tridof1[3 * trid1] + 1, tridof1[3 * trid1] + 2, tridof1[3 * trid1 + 1], tridof1[3 * trid1 + 1] + 1, tridof1[3 * trid1 + 1] + 2, tridof1[3 * trid1 + 2], tridof1[3 * trid1 + 2] + 1, tridof1[3 * trid1 + 2] + 2]; // dof of the triangle three points where the integration point belongs (contact area 1)
                        int[int] df2 = [tridof2[3 * trid2], tridof2[3 * trid2] + 1, tridof2[3 * trid2] + 2, tridof2[3 * trid2 + 1], tridof2[3 * trid2 + 1] + 1, tridof2[3 * trid2 + 1] + 2, tridof2[3 * trid2 + 2], tridof2[3 * trid2 + 2] + 1, tridof2[3 * trid2 + 2] + 2]; // dof of the triangle three points where the integration point projection belongs (contact area 2)
                        real[int] phit1 = [phi1(ti1, ti2), phi1(ti1, ti2), phi1(ti1, ti2), phi2(ti1, ti2), phi2(ti1, ti2), phi2(ti1, ti2), phi3(ti1, ti2), phi3(ti1, ti2), phi3(ti1, ti2)]; // Shape functions
                        real[int] phit2 = [phi1(et1, et2), phi1(et1, et2), phi1(et1, et2), phi2(et1, et2), phi2(et1, et2), phi2(et1, et2), phi3(et1, et2), phi3(et1, et2), phi3(et1, et2)];
                        real[int] pt1 = [1. - norm1[3 * ii] * norm1[3 * ii], - norm1[3 * ii] * norm1[3 * ii + 1], - norm1[3 * ii] * norm1[3 * ii + 2], 1. - norm1[3 * ii] * norm1[3 * ii], - norm1[3 * ii] * norm1[3 * ii + 1], - norm1[3 * ii] * norm1[3 * ii + 2], 1. - norm1[3 * ii] * norm1[3 * ii], - norm1[3 * ii] * norm1[3 * ii + 1], - norm1[3 * ii] * norm1[3 * ii + 2]];
                        real[int] pt2 = [- norm1[3 * ii] * norm1[3 * ii + 1], 1. - norm1[3 * ii + 1] * norm1[3 * ii + 1], - norm1[3 * ii + 1] * norm1[3 * ii + 2], - norm1[3 * ii] * norm1[3 * ii + 1], 1. - norm1[3 * ii + 1] * norm1[3 * ii + 1], - norm1[3 * ii + 1] * norm1[3 * ii + 2], - norm1[3 * ii] * norm1[3 * ii + 1], 1. - norm1[3 * ii + 1] * norm1[3 * ii + 1], - norm1[3 * ii + 1] * norm1[3 * ii + 2]];
                        real[int] pt3 = [- norm1[3 * ii] * norm1[3 * ii + 2], - norm1[3 * ii + 1] * norm1[3 * ii + 2], 1. - norm1[3 * ii + 2] * norm1[3 * ii + 2], - norm1[3 * ii] * norm1[3 * ii + 2], - norm1[3 * ii + 1] * norm1[3 * ii + 2], 1. - norm1[3 * ii + 2] * norm1[3 * ii + 2], - norm1[3 * ii] * norm1[3 * ii + 2], - norm1[3 * ii + 1] * norm1[3 * ii + 2], 1. - norm1[3 * ii + 2] * norm1[3 * ii + 2]];
                        
                        real[int] aug1(9), aug2(9), aug3(9), aug1p(9), aug2p(9), aug3p(9);
                        for (int k = 0; k < 9; k++) {
                            aug1[k] = pt1[k] * phit1[k];
                            aug2[k] = pt2[k] * phit1[k];
                            aug3[k] = pt3[k] * phit1[k];
                            aug1p[k] = - pt1[k] * phit2[k];
                            aug2p[k] = - pt2[k] * phit2[k];
                            aug3p[k] = - pt3[k] * phit2[k];
                        }
                        
                        // Derivatives of ag1f ,ag2f ,ag3f
                        real[int] a2ag1f(9), a2ag2f(9), a2ag3f(9), a2ag1fp(9), a2ag2fp(9), a2ag3fp(9);
                        
                        real ag1fx = axxPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g1}a_{g1}(f)°(g1,g2,g3)
                        real ag1fy = axyPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g2}a_{g1}(f)°(g1,g2,g3)
                        real ag1fz = axzPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g3}a_{g1}(f)°(g1,g2,g3)
                        
                        real ag2fx = axyPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g1}a_{g2}(f)°(g1,g2,g3)
                        real ag2fy = ayyPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g2}a_{g2}(f)°(g1,g2,g3)
                        real ag2fz = ayzPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g3}a_{g2}(f)°(g1,g2,g3)
                        
                        real ag3fx = axzPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g1}a_{g3}(f)°(g1,g2,g3)
                        real ag3fy = ayzPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g2}a_{g3}(f)°(g1,g2,g3)
                        real ag3fz = azzPhiEpsilon(urt[0], urt[1], urt[2], epsphi); // a_{g3}a_{g3}(f)°(g1,g2,g3)
                        
                        for (int l = 0; l < 9; l++) {
                            // For dof of the first body
                            a2ag1f[l] = ag1fx * aug1[l] + ag1fy * aug2[l] + ag1fz * aug3[l];
                            a2ag2f[l] = ag2fx * aug1[l] + ag2fy * aug2[l] + ag2fz * aug3[l];
                            a2ag3f[l] = ag3fx * aug1[l] + ag3fy * aug2[l] + ag3fz * aug3[l];
                        }
                        for (int l = 0; l < 9; l++) {
                            // For dof of the projection
                            a2ag1fp[l] = ag1fx * aug1p[l] + ag1fy * aug2p[l] + ag1fz * aug3p[l];
                            a2ag2fp[l] = ag2fx * aug1p[l] + ag2fy * aug2p[l] + ag2fz * aug3p[l];
                            a2ag3fp[l] = ag3fx * aug1p[l] + ag3fy * aug2p[l] + ag3fz * aug3p[l];
                        }
                        
                        for (int l = 0; l < 9; l++) {
                            for (int k = 0; k < 9; k++) {
                                iddW1(df1[l], df1[k]) += - mucol * s[ii] * (a2ag1f[l] * aug1[k] + a2ag2f[l] * aug2[k] + a2ag3f[l] * aug3[k]) * wi * Si;
                                iddW2(df2[l], df2[k]) += - mucol * s[ii] * (a2ag1fp[l] * aug1p[k] + a2ag2fp[l] * aug2p[k] + a2ag3fp[l] * aug3p[k]) * wi * Si;
                                iddW3(df1[l], df2[k]) += - mucol * s[ii] * (a2ag1f[l] * aug1p[k] + a2ag2f[l] * aug2p[k] + a2ag3f[l] * aug3p[k]) * wi * Si;
                            }
                        }
                    }
<% } -%>
                }
            }
            
            iddW4 = iddW3' ;
            iddWW = [[iddW1, iddW3], [iddW4, iddW2]];
            
            return iddWW;
        }
        
        // The Lagrangian of the constraints
        matrix Hessian;
        func matrix hessianCnst(real[int] &X, real sigma, real[int] &lambda) {
            Hessian = sigma * iddW(X);
            return Hessian;
        }
        
        // *****CONSTRAINTS AND ITS DIFFERENTALS*****
        // Constraints
        func real[int] Cnst2(real[int] &X) {
            real[int] X1(ndof1);
            real[int] X2(ndof1 : (ndoft - 1));
            real[int] XU1(ndof1); // =X+U
            real[int] XU2(ndof1 : (ndoft - 1)); // =X+U
            X1 = X(0 : (ndof1 - 1));
            X2 = X(ndof1 : (ndoft - 1));
            XU1 = XYZ1 + X1;
            XU2 = XYZ2 + X2;
            real[int] Co(ncont1 + ncont2);
            Co = 0.;
            // First body
<% if (dimension === 2){ -%>
            real Li1, Li2;
<% } -%>
<% if (dimension !== 2){ -%>
            real[int] AB(9), ABT(9), ABT0(9), ve1(3), ve2(3), provec(3);
            real xpr1, ypr1, zpr1; // The coordinates of the projected point on the surface 2 for the ip points at the contact area 1
            real xpr2, ypr2, zpr2; // The coordinates of the projected point on the surface 1 for the ip points at the contact area 2
            real Si1, Si2; // Triangle area
<% } -%>
            for (int we = 0; we < ncont1; we++) {
                // Defining the ncont1 weak constraints (The number of constraints is equal to the number of shape functions defined on the nodes (P1))
<% if (dimension === 2){ -%>
                int dofcx = Jb1[dim * we]; // Dof x of the current node on the contact area 1 and corresponds to the shape function of the weak formulation
                int conn = Connevec1[dofcx]; // Segment number connected to the first node (= 1 or 2)
                for (int k = 0; k < conn; k++) {
                    // Loop on the connected segments of the contact area 1
                    int tic1 = Conne1(dofcx, k); // Segment id connected to the first node ID in 0,...,Mesh0.nbe
                    int dofx0 = segdof1[dim * tic1]; // Dof x of the first vertice of the segment
                    int dofx1 = segdof1[dim * tic1 + 1]; // Dof x of the second vertice of the segment
                    int iphi; // =0 or 1 = the corresponding shape function connected to the node of dof= dofcx
                    if (dofcx == dofx0) {
                        iphi = 0;
                    }
                    else {
                        iphi = 1;
                    }
                    Li1 = ((XYZ1[dofx1] - XYZ1[dofx0])^2 + (XYZ1[dofx1 + 1] - XYZ1[dofx0 + 1])^2)^0.5; // Length due to the integral by substitution
                    int IDINI1 = IDni1[tic1]; // Seg ID in 0,...,nseg1
                    for (int j = 0; j < integrationPointsNumber; j++) {
                        // Shape function of the first segment
                        int ii = j + IDINI1 * integrationPointsNumber;
                        real ti = integrationPointsPositions[j]; // The parameter of the ip point in the segment (integration rule)
                        real wi = integrationPointsWeights[j]; // Weight integration rule
                        real xi = intpip(ti, XU1[dofx0], XU1[dofx1]); // Abscissa of the ip points
                        real yi = intpip(ti, XU1[dofx0 + 1], XU1[dofx1 + 1]); // Ordinates of the ip points
                        
                        real tt = eta[ii];
                        int posi = pos[ii]; // The segment number of the closest segment
                        int dofp1 = segdof2[dim * posi]; // Dof x of the first vertice of the segment
                        int dofp2 = segdof2[dim * posi + 1]; // Dof x of the second vertice of the segment
                        AB[0] = XU2[dofp1];
                        AB[1] = XU2[dofp1 + 1];
                        AB[2] = XU2[dofp2];
                        AB[3] = XU2[dofp2 + 1];
                        real[int] P1X1 = P1Function(AB, tt); // Segment [x0,x1] => the closest point of (xp,yp) to the segment
                        real xpr1 = P1X1[0]; // The projected points on the contact area 2
                        real ypr1 = P1X1[1];
                        Co[we] += ((xi - xpr1) * norm1[dim * ii] + (yi - ypr1) * norm1[dim * ii + 1]) * phi1(ti, iphi) * wi * Li1; // The constraints
                    }
                }
<% } else { -%>
                int dofcx = dof1[3 * we]; // dof x of the current node on the contact area 1 and corresponds to the shape function of the weak formulation
                int conn = Connevec1[dofcx]; // triangle number connected to the first node
                for (int i = 0; i < conn; i++) {
                    // loop on the connected triangles
                    int tic1 = Conne1(dofcx, i); // Triangle id connected to the first node
                    
                    for (int k = 0; k < 3; k++) { ABT0[k] = XYZ1[tridof1[3 * tic1] + k]; }
                    // coord of the first node of the triangle with id="i"
                    for (int k = 0; k < 3; k++) { ABT0[k + 3] = XYZ1[tridof1[3 * tic1 + 1] + k]; }
                    // coord of the second node of the triangle with id="i"
                    for (int k = 0; k < 3; k++) { ABT0[k + 6] = XYZ1[tridof1[3 * tic1 + 2] + k]; }
                    // coord of the third node of the triangle with id="i"
                    
                    for (int k = 0; k < 3; k++) { ABT[k] = XU1[tridof1[3 * tic1] + k]; }
                    // coord of the first node of the triangle with id="i"
                    for (int k = 0; k < 3; k++) { ABT[k + 3] = XU1[tridof1[3 * tic1 + 1] + k]; }
                    // coord of the second node of the triangle with id="i"
                    for (int k = 0; k < 3; k++) { ABT[k + 6] = XU1[tridof1[3 * tic1 + 2] + k]; }
                    // coord of the third node of the triangle with id="i"
                    
                    int iphi; // =1 or 2 or 3 = the corresponding shape function connected to the node of dof= dofcx
                    if (dofcx == tridof1[3 * tic1]) {
                        iphi = 1;
                    }
                    else {
                        if (dofcx == tridof1[3 * tic1 + 1]) {
                            iphi = 2;
                        }
                        else {
                            iphi = 3;
                        }
                    }
                    
                    PO1 = ABT0(0 : 2); // first point of the triangle
                    PO2 = ABT0(3 : 5); // second point of the triangle
                    PO3 = ABT0(6 : 8); // third point of the triangle
                    ve1 = PO2 - PO1;
                    ve2 = PO3 - PO1;
                    provec = vectorProduct(ve1, ve2); // Vectorial product in order to compute the area of the actual triangle where the integration is done
                    Si1 = (provec[0]^2 + provec[1]^2 + provec[2]^2)^0.5; // = 2* The surface of the actual triangle where the integration is done (contact area 1), correspond to variable changes in the surface integral
                    int ID1tri = tri1[tic1]; // Tri ID in 0,...,ntri1
                    for (int j = 0; j < integrationPointsNumber; j++) {
                        // loop on the integration points of each triangle
                        int ii = j + ID1tri * integrationPointsNumber;
                        real ti1 = integrationPointsPositions1[j]; // eta1 parameter of the triangle
                        real ti2 = integrationPointsPositions2[j]; // eta2 parameter of the triangle
                        real wi = integrationPointsWeights[j];
                        
                        real[int] PX = P1Function(ABT, ti1, ti2);
                        real xi = PX[0]; // abscissa of the ip points
                        real yi = PX[1]; // ordinates of the ip points
                        real zi = PX[2]; // Height of the ip points
                        
                        real et1 = eta[2 * ii]; // eta1 parameter of the triangle
                        real et2 = eta[2 * ii + 1]; // eta2 parameter of the triangle
                        int trid2 = tid1[ii]; // Triangle id \in contact area 2 closest to the integration point
                        
                        int dofp1 = tridof2[3 * trid2]; // dof x for the first node of the triangle with id="trid2"
                        int dofp2 = tridof2[3 * trid2 + 1]; // dof x for the second node of the triangle with id="trid2"
                        int dofp3 = tridof2[3 * trid2 + 2]; // dof x for the third node of the triangle with id="trid2"
                        
                        for (int k = 0; k < 3; k++) { AB[k] = XU2[dofp1 + k]; }
                        // coord of the first node of the triangle with id="trid2"
                        for (int k = 0; k < 3; k++) { AB[k + 3] = XU2[dofp2 + k]; }
                        // coord of the second node of the triangle with id="trid2"
                        for (int k = 0; k < 3; k++) { AB[k + 6] = XU2[dofp3 + k]; }
                        // coord of the third node of the triangle with id="trid2"
                        real[int] P1X = P1Function(AB, et1, et2); // The coordinates of the ip points
                        xpr1 = P1X[0]; // x of the projected point on the surface 2 for the ip points at the contact area 1
                        ypr1 = P1X[1]; // y of the projected point on the surface 2 for the ip points at the contact area 1
                        zpr1 = P1X[2]; // z of the projected point on the surface 2 for the ip points at the contact area 1
                        
                        Co[we] += ((xi - xpr1) * norm1[3 * ii] + (yi - ypr1) * norm1[3 * ii + 1] + (zi - zpr1) * norm1[3 * ii + 2]) * phi(ti1, ti2, iphi) * wi * Si1;
                    }
                }
<% } -%>
                
            }
            // Second body
            for (int we = 0; we < ncont2; we++) {
                // Defining the ncont1 weak constraints (The number of constraints is equal to the number of shape functions defined on the nodes (P1))
<% if (dimension === 2){ -%>
                int dofcx = Jb2[dim * we]; // Dof x of the current node on the contact area 1 and corresponds to the shape function of the weak formulation
                int conn = Connevec2[dofcx]; // Segment number connected to the first node (= 1 or 2)
                for (int k = 0; k < conn; k++) {
                    // Loop on the connected segments of the contact area 1
                    int tic2 = Conne2(dofcx, k); // Segment id connected to the first node ID in 0,...,Mesh0.nbe
                    int dofx0 = segdof2[dim * tic2]; // Dof x of the first vertice of the segment
                    int dofx1 = segdof2[dim * tic2 + 1]; // Dof x of the second vertice of the segment
                    int iphi; // =0 or 1 = the corresponding shape function connected to the node of dof= dofcx
                    if (dofcx == dofx0) {
                        iphi = 0;
                    }
                    else {
                        iphi = 1;
                    }
                    Li2 = ((XYZ2[dofx1] - XYZ2[dofx0])^2 + (XYZ2[dofx1 + 1] - XYZ2[dofx0 + 1])^2)^0.5; // Length due to the integral by substitution
                    int IDINI2 = IDni2[tic2]; // Seg ID in 0,...,nseg1
                    for (int j = 0; j < integrationPointsNumber; j++) {
                        // Shape function of the first segment
                        int ii = j + IDINI2 * integrationPointsNumber;
                        real ti = integrationPointsPositions[j]; // The parameter of the ip point in the segment (integration rule)
                        real wi = integrationPointsWeights[j]; // Weight integration rule
                        real xi = intpip(ti, XU2[dofx0], XU2[dofx1]); // Abscissa of the ip points
                        real yi = intpip(ti, XU2[dofx0 + 1], XU2[dofx1 + 1]); // Ordinates of the ip points
                        
                        real tt = eta2[ii];
                        int posi = pos2[ii]; // The segment number of the closest segment
                        int dofp1 = segdof1[dim * posi]; // Dof x of the first vertice of the segment
                        int dofp2 = segdof1[dim * posi + 1]; // Dof x of the second vertice of the segment
                        AB[0] = XU1[dofp1];
                        AB[1] = XU1[dofp1 + 1];
                        AB[2] = XU1[dofp2];
                        AB[3] = XU1[dofp2 + 1];
                        real[int] P1X1 = P1Function(AB, tt); // Segment [x0,x1] => the closest point of (xp,yp) to the segment
                        real xpr2 = P1X1[0]; // The projected points on the contact area 2
                        real ypr2 = P1X1[1];
                        Co[we + ncont1] += ((xi - xpr2) * norm2[dim * ii] + (yi - ypr2) * norm2[dim * ii + 1]) * phi1(ti, iphi) * wi * Li2; // The constraints
                    }
                }
<% } else { -%>
                int dofcx = dof2[3 * we]; // dof x of the current node on the contact area 1 and corresponds to the shape function of the weak formulation
                int conn = Connevec2[dofcx]; // triangle number connected to the first node
                for (int i = 0; i < conn; i++) {
                    // loop on the connected triangles
                    int tic1 = Conne2(dofcx, i); // Triangle id connected to the first node
                    
                    for (int k = 0; k < 3; k++) { ABT0[k] = XYZ2[tridof2[3 * tic1] + k]; }
                    // coord of the first node of the triangle with id="i"
                    for (int k = 0; k < 3; k++) { ABT0[k + 3] = XYZ2[tridof2[3 * tic1 + 1] + k]; }
                    // coord of the second node of the triangle with id="i"
                    for (int k = 0; k < 3; k++) { ABT0[k + 6] = XYZ2[tridof2[3 * tic1 + 2] + k]; }
                    // coord of the third node of the triangle with id="i"
                    
                    for (int k = 0; k < 3; k++) { ABT[k] = XU2[tridof2[3 * tic1] + k]; }
                    // coord of the first node of the triangle with id="i"
                    for (int k = 0; k < 3; k++) { ABT[k + 3] = XU2[tridof2[3 * tic1 + 1] + k]; }
                    // coord of the second node of the triangle with id="i"
                    for (int k = 0; k < 3; k++) { ABT[k + 6] = XU2[tridof2[3 * tic1 + 2] + k]; }
                    // coord of the third node of the triangle with id="i"
                    
                    int iphi; // =1 or 2 or 3 = the corresponding shape function connected to the node of dof= dofcx
                    if (dofcx == tridof2[3 * tic1]) {
                        iphi = 1;
                    }
                    else {
                        if (dofcx == tridof2[3 * tic1 + 1]) {
                            iphi = 2;
                        }
                        else {
                            iphi = 3;
                        }
                    }
                    
                    PO1 = ABT0(0 : 2); // first point of the triangle
                    PO2 = ABT0(3 : 5); // second point of the triangle
                    PO3 = ABT0(6 : 8); // third point of the triangle
                    ve1 = PO2 - PO1;
                    ve2 = PO3 - PO1;
                    provec = vectorProduct(ve1, ve2); // Vectorial product in order to compute the area of the actual triangle where the integration is done
                    Si2 = (provec[0]^2 + provec[1]^2 + provec[2]^2)^0.5; // = 2* The surface of the actual triangle where the integration is done (contact area 2), correspond to variable changes in the surface integral
                    int ID2tri = tri2[tic1]; // Tri ID in 0,...,ntri2
                    for (int j = 0; j < integrationPointsNumber; j++) {
                        // loop on the integration points of each triangle
                        int ii = j + ID2tri * integrationPointsNumber;
                        real ti1 = integrationPointsPositions1[j]; // eta1 parameter of the triangle
                        real ti2 = integrationPointsPositions2[j]; // eta2 parameter of the triangle
                        real wi = integrationPointsWeights[j];
                        
                        real[int] PX = P1Function(ABT, ti1, ti2);
                        real xi = PX[0]; // abscissa of the ip points
                        real yi = PX[1]; // ordinates of the ip points
                        real zi = PX[2]; // Height of the ip points
                        
                        real et1 = eta2[2 * ii]; // eta1 parameter of the triangle
                        real et2 = eta2[2 * ii + 1]; // eta2 parameter of the triangle
                        int trid2 = tid2[ii]; // Triangle id \in contact area 1 closest to the integration point
                        
                        int dofp1 = tridof1[3 * trid2]; // dof x for the first node of the triangle with id="trid2"
                        int dofp2 = tridof1[3 * trid2 + 1]; // dof x for the second node of the triangle with id="trid2"
                        int dofp3 = tridof1[3 * trid2 + 2]; // dof x for the third node of the triangle with id="trid2"
                        
                        for (int k = 0; k < 3; k++) { AB[k] = XU1[dofp1 + k]; }
                        // coord of the first node of the triangle with id="trid2"
                        for (int k = 0; k < 3; k++) { AB[k + 3] = XU1[dofp2 + k]; }
                        // coord of the second node of the triangle with id="trid2"
                        for (int k = 0; k < 3; k++) { AB[k + 6] = XU1[dofp3 + k]; }
                        // coord of the third node of the triangle with id="trid2"
                        real[int] P1X = P1Function(AB, et1, et2); // The coordinates of the ip points
                        xpr1 = P1X[0]; // x of the projected point on the surface 1 for the ip points at the contact area 2
                        ypr1 = P1X[1]; // y of the projected point on the surface 1 for the ip points at the contact area 2
                        zpr1 = P1X[2]; // z of the projected point on the surface 1 for the ip points at the contact area 2
                        
                        Co[we + ncont1] += ((xi - xpr1) * norm2[3 * ii] + (yi - ypr1) * norm2[3 * ii + 1] + (zi - zpr1) * norm2[3 * ii + 2]) * phi(ti1, ti2, iphi) * wi * Si2;
                    }
                }
<% } -%>
                
            }
            return Co;
        }
        // Constraints
        
        // Jacobian of the constraints
        real[int, int] Jac1(ncont1 + ncont2, ndof1);
        real[int, int] Jac2(ncont1 + ncont2, ndof2);
        matrix JACOB;
        matrix JACOB1;
        matrix JACOB2;
        JACOB.resize(ncont1 + ncont2, ndoft);
        JACOB1.resize(ncont1 + ncont2, ndof1);
        JACOB2.resize(ncont1 + ncont2, ndof2);
        {
            // The Jacobian of the constraints is constant
            // First body
            Jac1 = 0.;
            Jac2 = 0.;
            JACOB1 = Jac1;
            JACOB2 = Jac2;
<% if (dimension === 2){ -%>
            real Li1, Li2;
<% } -%>
<% if (dimension !== 2){ -%>
            real[int] ABT(9), ve1(3), ve2(3), provec(3);
            real Si1, Si2; // Triangle area
<% } -%>
            for (int we = 0; we < ncont1; we++) {
                // Defining the ncont1 weak constraints (The number of constraints is equal to the number of shape functions defined on the nodes (P1))
<% if (dimension === 2){ -%>
                int dofcx = Jb1[dim * we]; // dof x of the current node on the contact area 1 and corresponds to the shape function of the weak formulation
                int conn = Connevec1[dofcx]; // Segment number connected to the first node (= 1 or 2)
                for (int k = 0; k < conn; k++) {
                    // Loop on the segments of the contact area 1
                    int tic1 = Conne1(dofcx, k); // Segment id connected to the first node ID in 0,...,Mesh0.nbe
                    int dofx0 = segdof1[dim * tic1]; // dof x of the first vertice of the segment
                    int dofx1 = segdof1[dim * tic1 + 1]; // dof x of the secondt vertice of the segment
                    int iphi; // =0 or 1 = the corresponding shape function connected to the node of dof= dofcx
                    if (dofcx == dofx0) {
                        iphi = 0;
                    }
                    else {
                        iphi = 1;
                    }
                    Li1 = ((XYZ1[dofx1] - XYZ1[dofx0])^2 + (XYZ1[dofx1 + 1] - XYZ1[dofx0 + 1])^2)^0.5; // Length due to the integral by substitution
                    int IDINI1 = IDni1[tic1]; // Seg ID in 0,...,nseg1
                    for (int j = 0; j < integrationPointsNumber; j++) {
                        // shape function of the first segment
                        int ii = j + IDINI1 * integrationPointsNumber;
                        real tt = eta[ii];
                        int posi = pos[ii]; // The segment number of the closest segment
                        int dofp1 = segdof2[2 * posi]; // Dof x of the first vertice of the segment
                        int dofp2 = segdof2[2 * posi + 1]; // Dof x of the second vertice of the segmen
                        
                        real ph1 = 1 - tt;
                        real ph2 = tt;
                        
                        real ti = integrationPointsPositions[j]; // the parameter of the ip point in the segment (integration rule)
                        real wi = integrationPointsWeights[j]; // weight integration rule
                        JACOB1(we, dofx0) += (1 - ti) * norm1[2 * ii] * phi1(ti, iphi) * wi * Li1;
                        JACOB1(we, dofx0 + 1) += (1 - ti) * norm1[2 * ii + 1] * phi1(ti, iphi) * wi * Li1;
                        JACOB1(we, dofx1) += ti * norm1[2 * ii] * phi1(ti, iphi) * wi * Li1;
                        JACOB1(we, dofx1 + 1) += ti * norm1[2 * ii + 1] * phi1(ti, iphi) * wi * Li1;
                        
                        JACOB2(we, dofp1) -= ph1 * norm1[2 * ii] * phi1(ti, iphi) * wi * Li1;
                        JACOB2(we, dofp1 + 1) -= ph1 * norm1[2 * ii + 1] * phi1(ti, iphi) * wi * Li1;
                        JACOB2(we, dofp2) -= ph2 * norm1[2 * ii] * phi1(ti, iphi) * wi * Li1;
                        JACOB2(we, dofp2 + 1) -= ph2 * norm1[2 * ii + 1] * phi1(ti, iphi) * wi * Li1;
                    }
                }
<% } else { -%>
                int dofcx = dof1[3 * we]; // dof x of the current node on the contact area 1 and corresponds to the shape function of the weak formulation
                int conn = Connevec1[dofcx]; // triangle number connected to the first node
                for (int i = 0; i < conn; i++) {
                    // loop on the connected triangles
                    int tic1 = Conne1(dofcx, i); // Triangle id connected to the first node
                    
                    for (int k = 0; k < 3; k++) { ABT[k] = XYZ1[tridof1[3 * tic1] + k]; }
                    // coord of the first node of the triangle with id="i"
                    for (int k = 0; k < 3; k++) { ABT[k + 3] = XYZ1[tridof1[3 * tic1 + 1] + k]; }
                    // coord of the second node of the triangle with id="i"
                    for (int k = 0; k < 3; k++) { ABT[k + 6] = XYZ1[tridof1[3 * tic1 + 2] + k]; }
                    // coord of the third node of the triangle with id="i"
                    
                    int iphi; // =1 or 2 or 3 = the corresponding shape function connected to the node of dof= dofcx
                    if (dofcx == tridof1[3 * tic1]) {
                        iphi = 1;
                    }
                    else {
                        if (dofcx == tridof1[3 * tic1 + 1]) {
                            iphi = 2;
                        }
                        else {
                            iphi = 3;
                        }
                    }
                    
                    PO1 = ABT(0 : 2); // first point of the triangle
                    PO2 = ABT(3 : 5); // second point of the triangle
                    PO3 = ABT(6 : 8); // third point of the triangle
                    ve1 = PO2 - PO1;
                    ve2 = PO3 - PO1;
                    provec = vectorProduct(ve1, ve2); // Vectorial product in order to compute the area of the actual triangle where the integration is done
                    Si1 = (provec[0]^2 + provec[1]^2 + provec[2]^2)^0.5; // = 2* The surface of the actual triangle where the integration is done (contact area 1), correspond to variable changes in the surface integral
                    int ID1tri = tri1[tic1]; // Tri ID in 0,...,ntri1
                    for (int j = 0; j < integrationPointsNumber; j++) {
                        // loop on the integration points of each triangle
                        int ii = j + ID1tri * integrationPointsNumber;
                        real ti1 = integrationPointsPositions1[j]; // eta1 parameter of the triangle
                        real ti2 = integrationPointsPositions2[j]; // eta2 parameter of the triangle
                        real wi = integrationPointsWeights[j];
                        
                        real et1 = eta[2 * ii]; // eta1 parameter of the triangle
                        real et2 = eta[2 * ii + 1]; // eta2 parameter of the triangle
                        int trid2 = tid1[ii]; // Triangle id \in contact area 2 closest to the integration point
                        
                        // degree of freedom of (x_vertice1, y_vertice1, z_vertice1, x_vertice2, y_vertice2, z_vertice2, ... ) of the triangle
                        int[int] df1 = [tridof1[3 * tic1], tridof1[3 * tic1] + 1, tridof1[3 * tic1] + 2, tridof1[3 * tic1 + 1], tridof1[3 * tic1 + 1] + 1, tridof1[3 * tic1 + 1] + 2, tridof1[3 * tic1 + 2], tridof1[3 * tic1 + 2] + 1, tridof1[3 * tic1 + 2] + 2]; // dof of the triangle three points where the integration point belongs (contact area 1)
                        int[int] df2 = [tridof2[3 * trid2], tridof2[3 * trid2] + 1, tridof2[3 * trid2] + 2, tridof2[3 * trid2 + 1], tridof2[3 * trid2 + 1] + 1, tridof2[3 * trid2 + 1] + 2, tridof2[3 * trid2 + 2], tridof2[3 * trid2 + 2] + 1, tridof2[3 * trid2 + 2] + 2]; // dof of the triangle three points where the integration point projection belongs (contact area 2)
                        real[int] nor1 = [norm1[3 * ii], norm1[3 * ii + 1], norm1[3 * ii + 2], norm1[3 * ii], norm1[3 * ii + 1], norm1[3 * ii + 2], norm1[3 * ii], norm1[3 * ii + 1], norm1[3 * ii + 2]];
                        real[int] phit1 = [phi1(ti1, ti2), phi1(ti1, ti2), phi1(ti1, ti2), phi2(ti1, ti2), phi2(ti1, ti2), phi2(ti1, ti2), phi3(ti1, ti2), phi3(ti1, ti2), phi3(ti1, ti2)];
                        real[int] phit2 = [phi1(et1, et2), phi1(et1, et2), phi1(et1, et2), phi2(et1, et2), phi2(et1, et2), phi2(et1, et2), phi3(et1, et2), phi3(et1, et2), phi3(et1, et2)];
                        for (int k = 0; k < 9; k++) {
                            JACOB1(we, df1[k]) += phit1[k] * nor1[k] * phi(ti1, ti2, iphi) * wi * Si1;
                            JACOB2(we, df2[k]) -= phit2[k] * nor1[k] * phi(ti1, ti2, iphi) * wi * Si1;
                        }
                    }
                }
<% } -%>
            }
            // Sevond body
            for (int we = 0; we < ncont2; we++) {
                // Defining the ncont1 weak constraints (The number of constraints is equal to the number of shape functions defined on the nodes (P1))
<% if (dimension === 2){ -%>
                int dofcx = Jb2[dim * we]; // dof x of the current node on the contact area 1 and corresponds to the shape function of the weak formulation
                int conn = Connevec2[dofcx]; // Segment number connected to the first node (= 1 or 2)
                for (int k = 0; k < conn; k++) {
                    // Loop on the segments of the contact area 1
                    int tic2 = Conne2(dofcx, k); // Segment id connected to the first node ID in 0,...,Mesh0.nbe
                    int dofx0 = segdof2[dim * tic2]; // dof x of the first vertice of the segment
                    int dofx1 = segdof2[dim * tic2 + 1]; // dof x of the secondt vertice of the segment
                    int iphi; // =0 or 1 = the corresponding shape function connected to the node of dof= dofcx
                    if (dofcx == dofx0) {
                        iphi = 0;
                    }
                    else {
                        iphi = 1;
                    }
                    Li2 = ((XYZ2[dofx1] - XYZ2[dofx0])^2 + (XYZ2[dofx1 + 1] - XYZ2[dofx0 + 1])^2)^0.5; // Length due to the integral by substitution
                    int IDINI2 = IDni2[tic2]; // Seg ID in 0,...,nseg1
                    for (int j = 0; j < integrationPointsNumber; j++) {
                        // shape function of the first segment
                        int ii = j + IDINI2 * integrationPointsNumber;
                        real tt = eta2[ii];
                        int posi = pos2[ii]; // The segment number of the closest segment
                        int dofp1 = segdof1[2 * posi]; // Dof x of the first vertice of the segment
                        int dofp2 = segdof1[2 * posi + 1]; // Dof x of the second vertice of the segmen
                        
                        real ph1 = 1 - tt;
                        real ph2 = tt;
                        
                        real ti = integrationPointsPositions[j]; // the parameter of the ip point in the segment (integration rule)
                        real wi = integrationPointsWeights[j]; // weight integration rule
                        JACOB2(we + ncont1, dofx0) += (1 - ti) * norm2[2 * ii] * phi1(ti, iphi) * wi * Li2;
                        JACOB2(we + ncont1, dofx0 + 1) += (1 - ti) * norm2[2 * ii + 1] * phi1(ti, iphi) * wi * Li2;
                        JACOB2(we + ncont1, dofx1) += ti * norm2[2 * ii] * phi1(ti, iphi) * wi * Li2;
                        JACOB2(we + ncont1, dofx1 + 1) += ti * norm2[2 * ii + 1] * phi1(ti, iphi) * wi * Li2;
                        
                        JACOB1(we + ncont1, dofp1) -= ph1 * norm2[2 * ii] * phi1(ti, iphi) * wi * Li2;
                        JACOB1(we + ncont1, dofp1 + 1) -= ph1 * norm2[2 * ii + 1] * phi1(ti, iphi) * wi * Li2;
                        JACOB1(we + ncont1, dofp2) -= ph2 * norm2[2 * ii] * phi1(ti, iphi) * wi * Li2;
                        JACOB1(we + ncont1, dofp2 + 1) -= ph2 * norm2[2 * ii + 1] * phi1(ti, iphi) * wi * Li2;
                    }
                }
<% } else { -%>
                int dofcx = dof2[3 * we]; // dof x of the current node on the contact area 1 and corresponds to the shape function of the weak formulation
                int conn = Connevec2[dofcx]; // triangle number connected to the first node
                for (int i = 0; i < conn; i++) {
                    // loop on the connected triangles
                    int tic1 = Conne2(dofcx, i); // Triangle id connected to the first node
                    
                    for (int k = 0; k < 3; k++) { ABT[k] = XYZ2[tridof2[3 * tic1] + k]; }
                    // coord of the first node of the triangle with id="i"
                    for (int k = 0; k < 3; k++) { ABT[k + 3] = XYZ2[tridof2[3 * tic1 + 1] + k]; }
                    // coord of the second node of the triangle with id="i"
                    for (int k = 0; k < 3; k++) { ABT[k + 6] = XYZ2[tridof2[3 * tic1 + 2] + k]; }
                    // coord of the third node of the triangle with id="i"
                    
                    int iphi; // =1 or 2 or 3 = the corresponding shape function connected to the node of dof= dofcx
                    if (dofcx == tridof2[3 * tic1]) {
                        iphi = 1;
                    }
                    else {
                        if (dofcx == tridof2[3 * tic1 + 1]) {
                            iphi = 2;
                        }
                        else {
                            iphi = 3;
                        }
                    }
                    
                    PO1 = ABT(0 : 2); // first point of the triangle
                    PO2 = ABT(3 : 5); // second point of the triangle
                    PO3 = ABT(6 : 8); // third point of the triangle
                    ve1 = PO2 - PO1;
                    ve2 = PO3 - PO1;
                    provec = vectorProduct(ve1, ve2); // Vectorial product in order to compute the area of the actual triangle where the integration is done
                    Si2 = (provec[0]^2 + provec[1]^2 + provec[2]^2)^0.5; // = 2* The surface of the actual triangle where the integration is done (contact area 2), correspond to variable changes in the surface integral
                    int ID2tri = tri2[tic1]; // Tri ID in 0,...,ntri2
                    for (int j = 0; j < integrationPointsNumber; j++) {
                        // loop on the integration points of each triangle
                        int ii = j + ID2tri * integrationPointsNumber;
                        real ti1 = integrationPointsPositions1[j]; // eta1 parameter of the triangle
                        real ti2 = integrationPointsPositions2[j]; // eta2 parameter of the triangle
                        real wi = integrationPointsWeights[j];
                        
                        real et1 = eta2[2 * ii]; // eta1 parameter of the triangle
                        real et2 = eta2[2 * ii + 1]; // eta2 parameter of the triangle
                        int trid2 = tid2[ii]; // Triangle id \in contact area 1 closest to the integration point
                        
                        // degree of freedom of (x_vertice1, y_vertice1, z_vertice1, x_vertice2, y_vertice2, z_vertice2, ... ) of the triangle
                        int[int] df1 = [tridof2[3 * tic1], tridof2[3 * tic1] + 1, tridof2[3 * tic1] + 2, tridof2[3 * tic1 + 1], tridof2[3 * tic1 + 1] + 1, tridof2[3 * tic1 + 1] + 2, tridof2[3 * tic1 + 2], tridof2[3 * tic1 + 2] + 1, tridof2[3 * tic1 + 2] + 2]; // dof of the triangle three points where the integration point belongs (contact area 2)
                        int[int] df2 = [tridof1[3 * trid2], tridof1[3 * trid2] + 1, tridof1[3 * trid2] + 2, tridof1[3 * trid2 + 1], tridof1[3 * trid2 + 1] + 1, tridof1[3 * trid2 + 1] + 2, tridof1[3 * trid2 + 2], tridof1[3 * trid2 + 2] + 1, tridof1[3 * trid2 + 2] + 2]; // dof of the triangle three points where the integration point projection belongs (contact area 1)
                        real[int] nor1 = [norm2[3 * ii], norm2[3 * ii + 1], norm2[3 * ii + 2], norm2[3 * ii], norm2[3 * ii + 1], norm2[3 * ii + 2], norm2[3 * ii], norm2[3 * ii + 1], norm2[3 * ii + 2]];
                        real[int] phit1 = [phi1(ti1, ti2), phi1(ti1, ti2), phi1(ti1, ti2), phi2(ti1, ti2), phi2(ti1, ti2), phi2(ti1, ti2), phi3(ti1, ti2), phi3(ti1, ti2), phi3(ti1, ti2)];
                        real[int] phit2 = [phi1(et1, et2), phi1(et1, et2), phi1(et1, et2), phi2(et1, et2), phi2(et1, et2), phi2(et1, et2), phi3(et1, et2), phi3(et1, et2), phi3(et1, et2)];
                        for (int k = 0; k < 9; k++) {
                            JACOB2(we + ncont1, df1[k]) += phit1[k] * nor1[k] * phi(ti1, ti2, iphi) * wi * Si2;
                            JACOB1(we + ncont1, df2[k]) -= phit2[k] * nor1[k] * phi(ti1, ti2, iphi) * wi * Si2;
                        }
                    }
                }
<% } -%>
            }
            JACOB = [[JACOB1, JACOB2]];
        }
        
        real[int] GAP(ncont1 + ncont2);
        real[int] NULDIS(ndoft);
        NULDIS = 0.;
        GAP = Cnst2(NULDIS);
        // Constraints
        func real[int] Cnst(real[int] &X) {
            real[int] AX(ncont1 + ncont2);
            AX = JACOB * X;
            AX += GAP;
            return AX;
        }
        // Constraints
        
        func matrix jacCnst(real[int] &X) {
            return JACOB;
        }
        
        real[int] cl(ncont1 + ncont2); cl = 0.; // constraints lower bounds (no upper bounds)
        
        // Boundary conditions for the body
        
        // Body 1
        real[int] ub1(ndof1), lb1(ndof1);
        ub1 = 1e19;
        lb1 = - 1e19;
        
        // Fixed boundary
        varf vGammafixed(<%- testfunc2 -%>, <%- testfunc1 -%>) =
            // truc à la con pour éviter à gérer le + au début ou valeur vide
            intN(Mesh0)(0 * Vx)
<% for (const f of fixed){ -%>
<%
if (f.geometryIndex === 0){
%>
            + on(<%- f.labels -%>, Wx = 1, Wy = 1 <% if (dimension !== 2){ -%>, Wz = 1 <% } -%>)
<% } -%>
<% } -%>
            ;
        real[int] onGammafixed = vGammafixed(0, Wh1, tgv = 1);
        for (int i = 0; i < ((ub1.n) / dim); i++) {
            if (onGammafixed[dim * i]) { ub1[dim * i] = 0; lb1[dim * i] = 0; ub1[dim * i + 1] = 0; lb1[dim * i + 1] = 0; <% if (dimension !== 2){ -%> ub1[dim * i + 2] = 0; lb1[dim * i + 2] = 0; <% } -%> }
            // Clamped
        }
        
        // Imposed displacement
<% var comp = 0 -%>
<% for (const d of displacement){ -%>
<%
if (d.geometryIndex === 0){
%>
<% comp = comp + 1 -%>
        varf vGammadisp1<%- comp -%>(<%- testfunc2 -%>, <%- testfunc1 -%>) = on(<%- d.labels -%>, Wx = 1, Wy = 1 <% if (dimension !== 2){ -%>, Wz = 1 <% } -%>);
        real[int] onGammadisp1<%- comp -%> = vGammadisp1<%- comp -%>(0, Wh1, tgv = 1);
<% if (d.values[0].checked || d.values[1].checked || d.values[2].checked){ -%>
        for (int i = 0; i < ((ub1.n) / dim); i++) {
            if (onGammadisp1<%- comp -%>[dim * i]) {
<% if (d.values[0].checked){ -%> ub1[dim * i] = <%- d.values[0].value ?? d.values[0].default -%>; lb1[dim * i] = <%- d.values[0].value ?? d.values[0].default -%>; <% } -%>
<% if (d.values[1].checked){ -%> ub1[dim * i + 1] = <%- d.values[1].value ?? d.values[1].default -%>; lb1[dim * i + 1] = <%- d.values[1].value ?? d.values[1].default -%>; <% } -%>
<% if (dimension !== 2){ -%>
<% if (d.values[2].checked){ -%> ub1[dim * i + 2] = <%- d.values[2].value ?? d.values[2].default -%>; lb1[dim * i + 2] = <%- d.values[2].value ?? d.values[2].default -%>; <% } -%>
<% } -%>
            }
        }
<% } -%>
<% } -%>
<% } -%>
        
        // Body 2
        real[int] ub2(ndof2), lb2(ndof2);
        ub2 = 1e19;
        lb2 = - 1e19;
        
        // Fixed boundary
        varf vGammafixed2(<%- testfunc2 -%>, <%- testfunc1 -%>) =
            // truc à la con pour éviter à gérer le + au début ou valeur vide
            intN(Mesh1)(0 * Vx)
<% for (const f of fixed){ -%>
<%
if (f.geometryIndex === 1){
%>
            + on(<%- f.labels -%>, Wx = 1, Wy = 1 <% if (dimension !== 2){ -%>, Wz = 1 <% } -%>)
<% } -%>
<% } -%>
            ;
        real[int] onGammafixed2 = vGammafixed2(0, Wh2, tgv = 1);
        for (int i = 0; i < ((ub2.n) / dim); i++) {
            if (onGammafixed2[dim * i]) { ub2[dim * i] = 0; lb2[dim * i] = 0; ub2[dim * i + 1] = 0; lb2[dim * i + 1] = 0; <% if (dimension !== 2){ -%> ub2[dim * i + 2] = 0; lb2[dim * i + 2] = 0; <% } -%> }
            // Clamped
        }
        
        // Imposed displacement
<% comp = 0 -%>
<% for (const d of displacement){ -%>
<%
if (d.geometryIndex === 1){
%>
<% comp = comp + 1 -%>
        varf vGammadisp2<%- comp -%>(<%- testfunc2 -%>, <%- testfunc1 -%>) = on(<%- d.labels -%>, Wx = 1, Wy = 1 <% if (dimension !== 2){ -%>, Wz = 1 <% } -%>);
        real[int] onGammadisp2<%- comp -%> = vGammadisp2<%- comp -%>(0, Wh2, tgv = 1);
<% if (d.values[0].checked || d.values[1].checked || d.values[2].checked){ -%>
        for (int i = 0; i < ((ub2.n) / dim); i++) {
            if (onGammadisp2<%- comp -%>[dim * i]) {
<% if (d.values[0].checked){ -%> ub2[dim * i] = <%- d.values[0].value ?? d.values[0].default -%>; lb2[dim * i] = <%- d.values[0].value ?? d.values[0].default -%>; <% } -%>
<% if (d.values[1].checked){ -%> ub2[dim * i + 1] = <%- d.values[1].value ?? d.values[1].default -%>; lb2[dim * i + 1] = <%- d.values[1].value ?? d.values[1].default -%>; <% } -%>
<% if (dimension !== 2){ -%>
<% if (d.values[2].checked){ -%> ub2[dim * i + 2] = <%- d.values[2].value ?? d.values[2].default -%>; lb2[dim * i + 2] = <%- d.values[2].value ?? d.values[2].default -%>; <% } -%>
<% } -%>
            }
        }
<% } -%>
<% } -%>
<% } -%>
        

    
                      
    // Von mises stress
    fespace Sh1(Mesh0, P2);
    Sh1 body1Epsilon11 = dx(U1x);
    Sh1 body1Epsilon22 = dy(U1y);
    Sh1 body1Epsilon33 = <% if (dimension === 2){ -%> 0 <% } else { -%> dz(U1z) <% } -%>;
    Sh1 body1Epsilon12 = 0.5 * (dy(U1x) + dx(U1y));
    Sh1 body1Epsilon13 = <% if (dimension === 2){ -%> 0 <% } else { -%> 0.5 * (dz(U1x) + dx(U1z)) <% } -%>;
    Sh1 body1Epsilon23 = <% if (dimension === 2){ -%> 0 <% } else { -%> 0.5 * (dy(U1z) + dz(U1y)) <% } -%>;
    Sh1 traceEpsilon1 = body1Epsilon11 + body1Epsilon22 + body1Epsilon33;
    Sh1 body1Gamma11 = 2. * Mu0 * body1Epsilon11 + Lambda0 * traceEpsilon1;
    Sh1 body1Gamma22 = 2. * Mu0 * body1Epsilon22 + Lambda0 * traceEpsilon1;
    Sh1 body1Gamma33 = 2. * Mu0 * body1Epsilon33 + Lambda0 * traceEpsilon1;
    Sh1 body1Gamma12 = 2. * Mu0 * body1Epsilon12;
    Sh1 body1Gamma13 = 2. * Mu0 * body1Epsilon13;
    Sh1 body1Gamma23 = 2. * Mu0 * body1Epsilon23;
    Sh1 body1Sigma = sqrt(
        0.5 * ((body1Gamma11 - body1Gamma22)^2 + (body1Gamma22 - body1Gamma33)^2 + (body1Gamma33 - body1Gamma11)^2)
        + 3. * (body1Gamma12^2 + body1Gamma23^2 + body1Gamma13^2)
    );
    // Von mises stress
    fespace Sh2(Mesh1, P2);
    Sh2 body2Epsilon11 = dx(U2x);
    Sh2 body2Epsilon22 = dy(U2y);
    Sh2 body2Epsilon33 = <% if (dimension === 2){ -%> 0 <% } else { -%> dz(U2z) <% } -%>;
    Sh2 body2Epsilon12 = 0.5 * (dy(U2x) + dx(U2y));
    Sh2 body2Epsilon13 = <% if (dimension === 2){ -%> 0 <% } else { -%> 0.5 * (dz(U2x) + dx(U2z)) <% } -%>;
    Sh2 body2Epsilon23 = <% if (dimension === 2){ -%> 0 <% } else { -%> 0.5 * (dy(U2z) + dz(U2y)) <% } -%>;
    Sh2 traceEpsilon2 = body2Epsilon11 + body2Epsilon22 + body2Epsilon33;
    Sh2 body2Gamma11 = 2. * Mu1 * body2Epsilon11 + Lambda1 * traceEpsilon2;
    Sh2 body2Gamma22 = 2. * Mu1 * body2Epsilon22 + Lambda1 * traceEpsilon2;
    Sh2 body2Gamma33 = 2. * Mu1 * body2Epsilon33 + Lambda1 * traceEpsilon2;
    Sh2 body2Gamma12 = 2. * Mu1 * body2Epsilon12;
    Sh2 body2Gamma13 = 2. * Mu1 * body2Epsilon13;
    Sh2 body2Gamma23 = 2. * Mu1 * body2Epsilon23;
    Sh2 body2Sigma = sqrt(
        0.5 * ((body2Gamma11 - body2Gamma22)^2 + (body2Gamma22 - body2Gamma33)^2 + (body2Gamma33 - body2Gamma11)^2)
        + 3. * (body2Gamma12^2 + body2Gamma23^2 + body2Gamma13^2)
    );
    
<%# Save -%>
<%- include('/blobs/save.edp.ejs', {
    dimension,
    path: run.resultPath,
    name: '"body1Result"',
    mesh: "Mesh0",
    geometry: {
        value: geometry?.values[0]
    },
    results: run.results[0]
}) -%>
<%- include('/blobs/save.edp.ejs', {
    dimension,
    path: run.resultPath,
    name: '"body2Result"',
    mesh: "Mesh1",
    geometry: {
        value: geometry?.values[1]
    },
    results: run.results[1]
}) -%>
<%# Sensors -%>
<%- include('/blobs/sensors.edp.ejs', {
    path: run.dataPath,
    x: 0,
    sensors: run.sensors
}) -%>
    appendLog("End");
} catch (...) {
    appendError("An internal error occurs");
    exit(- 1);
}

