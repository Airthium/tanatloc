try {
	<%# Headers -%>
	<%- include('/blobs/headers.edp.ejs') -%>

	<%# Dimension -%>
	<%- include('/blobs/dimensioning.edp.ejs', {
		dimension
	}); -%>

	<%# Mesh -%>
	<%
	const mesh = geometry.mesh
	mesh.name = 'Mesh'
	-%>

	<% if (initialization.value && initialization.value.type === 'coupling') { -%>
	meshN Mesh = readmesh3("<%= initialization.value.mesh -%>");
	<% } else { -%>
	<%- include('/blobs/mesh.edp.ejs', {
		dimension,
		mesh
	}); -%>
	<% } -%>

	// Variables
	real t = 0.;
	real T = <%= parameters.time.children[0].value ?? parameters.time.children[0].default -%>;
	real dt = <%= parameters.time.children[1].value ?? parameters.time.children[1].default -%>;

	<%# Materials -%>
	<%- include('/blobs/materials.edp.ejs', {
		materials
	}) -%>

	<%# Finite element space -%>
	<%
	const finiteElementSpace = parameters.finiteElementSpace.children[0]
	finiteElementSpace.name = 'Uh'
	-%>
	<%- include('/blobs/fespace.edp.ejs', {
		mesh,
		finiteElementSpace
	}); -%>

	<%# Finite element function -%>
	<%
	let feFunction = ['Ux', 'Uy', 'Uz', 'p']

	let unknownFunction = '[Ux, Uy, Uz, p]'
	let testFunction = '[Uhx, Uhy, Uhz, ph]'
	let freeFunction = '[mUx, mUy, mUz, mp]'

	let U = '[Ux, Uy, Uz]'
	let Uh = '[Uhx, Uhy, Uhz]'
	let N = '[N.x, N.y, N.z]'

	if (dimension === 2) {
		feFunction = ['Ux', 'Uy', 'p']

		unknownFunction = '[Ux, Uy, p]'
		testFunction = '[Uhx, Uhy, ph]'
		freeFunction = '[mUx, mUy, mp]'

		U = '[Ux, Uy]'
		Uh = '[Uhx, Uhy]'
		N = '[N.x, N.y]'
	}
	-%>
	<%- include('/blobs/fespaceFunction.edp.ejs', {
		finiteElementSpace,
		finiteElementFunction: feFunction
	}); -%>

	<%# Macro -%>
	<%- include('/blobs/macro.edp.ejs', {
		dimension,
		type: ['vectorialGradient', 'vectorialDivergence']
	}); -%>

	<%# Problem -%>
	<% 
	const wall = boundaryConditions.wall.values || []
	const freeOutlet = boundaryConditions.freeOutlet.values || []
	const dirichlet = boundaryConditions.dirichlet.values || []
	const neumann = boundaryConditions.neumann.values || []
	const rhs = parameters.rightHandSide.children
	const rhsX = rhs[0].value ?? rhs[0].default
	const rhsY = rhs[1].value ?? rhs[1].default
	const rhsZ = rhs[2].value ?? rhs[2].default
	-%> 
	//Problem
	appendLog("Define the problem...");

	real Rhodt = Rho / dt;
	varf vNavierStokes (<%= unknownFunction -%>, <%= testFunction -%>)
		= intN(Mesh)(
			Rhodt * <%= U -%>' * <%= Uh -%>
			+ Mu * (Grad(U) : Grad(Uh))
			- p * Div(Uh)
			- Div(U) * ph
		)
	<% for (const d of dirichlet) { -%>
		+ on(<%= d.selected.map(s => s.label).filter(s => s).join() -%>
		<% if (d.values[0].checked) { -%>, Ux=0<% } -%>
		<% if (d.values[1].checked) { -%>, Uy=0<% } -%>
		<% if (dimension !== 2 && d.values[2].checked) { -%>, Uz=0<% } -%>
		)
	<% } -%>
	<% for (const w of wall) { -%>
		+ on(<%= w.selected.map(s => s.label).filter(s => s).join() -%>, Ux=0, Uy=0<% if (dimension !== 2) { -%> , Uz=0<% } -%>)
	<% } -%>
		;

	varf vNavierStokesRHS (<%= freeFunction -%>, <%= testFunction -%>)
		= intN(Mesh)(
		<% if (dimension === 2) { -%>
			  Rhodt * [convect(<%= U -%>, -dt, Ux), convect(<%= U -%>, -dt, Uy)]' * <%= Uh -%>
			+ [<%- rhsX -%>, <%- rhsY -%>]' * <%= Uh %>
		<% } else { -%>
			  Rhodt * [convect(<%= U -%>, -dt, Ux), convect(<%= U -%>, -dt, Uy), convect(<%= U -%>, -dt, Uz)]' * <%= Uh -%>
			+ [<%- rhsX -%>, <%- rhsY -%>, <%- rhsZ -%>]' * <%= Uh %>
		<% } -%>
		)
	<% for (const n of neumann) { -%>
		- intN1(Mesh, <%= n.selected.map(s => s.label).filter(s => s).join() -%>)(
			(<%- n.values[0].value ?? n.values[0].default -%>) * <%= N -%>' * <%= testFunction -%>
		)
	<% } -%>
	<% for (const d of dirichlet) { -%>
		+ on(<%= d.selected.map(s => s.label).filter(s => s).join() -%>
		<% if (d.values[0].checked) { -%>, mUx=<%- d.values[0].value ?? d.values[0].default -%><% } -%>
		<% if (d.values[1].checked) { -%>, mUy=<%- d.values[1].value ?? d.values[1].default -%><% } -%>
		<% if (dimension !== 2 && d.values[2].checked) { -%>, mUz=<%- d.values[2].value ?? d.values[2].default -%><% } -%>)
	<% } -%>
	<% for (const w of wall) { -%>
		+ on(<%= w.selected.map(s => s.label).filter(s => s).join() -%>, mUx=0, mUy=0<% if (dimension !== 2) { -%> , mUz=0<% } -%>)
	<% } -%>
		;

	<%# Solver -%>
	<% const solver = parameters.solver.children[0].value ?? parameters.solver.children[0].default -%>
	<%- include('/blobs/solver.edp.ejs', {
		solver
	}); -%>

	<%# Initialization -%>
	// Initialization
	<% if (initialization.value) { -%>
	<% if (initialization.value.type === 'coupling') { -%>
	{
		ifstream couplingData("<%= initialization.value.dat -%>");
		<% if (dimension === 2) { -%>
		couplingData >> Ux[] >> Uy[];
		<% } else { -%>
		couplingData >> Ux[] >> Uy[] >> Uz[];
		<% } -%>
	}
	<% } else if (initialization.value.type === 'direct' && initialization.value.values ) { -%>
	<% if (dimension === 2) { -%>
	[<%= feFunction -%>] = [
		<%= initialization.value.values[0] ?? initialization.direct.children[0].default -%>,
		<%= initialization.value.values[1] ?? initialization.direct.children[1].default -%>
		0];
	<% } else { -%>
	[<%= feFunction -%>] = [
		<%= initialization.value.values[0] ?? initialization.direct.children[0].default -%>,
		<%= initialization.value.values[1] ?? initialization.direct.children[1].default -%>,
		<%= initialization.value.values[2] ?? initialization.direct.children[2].default -%>,
		0];
	<% } -%>
	<% } else { -%>
	<% if (dimension === 2) { -%>
	[<%= feFunction -%>] = [
		<%= initialization.direct.children[0].default -%>,
		<%= initialization.direct.children[1].default -%>,
		<%= initialization.direct.children[2].default -%>,
		0];
	<% } else { -%>
	[<%= feFunction -%>] = [
		<%= initialization.direct.children[0].default -%>,
		<%= initialization.direct.children[1].default -%>
		0];
	<% }-%>
	<% }-%>
	<% } -%>

	matrix NavierStokes = vNavierStokes(<%= finiteElementSpace.name -%>, <%= finiteElementSpace.name -%>, solver=solver);

	<%# Time loop -%>
	// Time loop
	appendLog("Time loop...");

	int nbIter = T / dt;
	for (int timeIter = 0; timeIter < nbIter; ++timeIter) {
		// Update
		t += dt;
		appendLog("Time: " + t);
		
		real[int] NavierStokesRHS = vNavierStokesRHS(0, <%= finiteElementSpace.name -%>);

		// Solve
		Ux[] = NavierStokes^-1 * NavierStokesRHS;

		// Save data
		real netFlow = intN1(Mesh)(<%= U -%>' * <%= N -%>);
		real div = intN(Mesh)(Div(U)) / intN(Mesh)(1);
		<%- include('/blobs/data.edp.ejs', {
			path: run.dataPath,
			fileName: '"iter_"+timeIter',
			dataNames: ['Net flow', 'Divergence', ],
			x: 't',
			ys: ['netFlow', 'div']
		}) -%>

		// Save coupling
		<%- include('/blobs/coupling.edp.ejs', {
			path: run.couplingPath,
			mesh: mesh.name,
			name: '"Result_"+timeIter',
			data: dimension === 2 ? ['Ux', 'Uy'] : ['Ux', 'Uy', 'Uz']
		}); -%>

		// Save results
		<%- include('/blobs/save.edp.ejs', {
			solution: {
				path: run.resultPath,
				name: '"Result_"+timeIter',
				mesh: mesh.name,
				sol: [dimension === 2 ? ['Ux', 'Uy', '0'] : ['Ux', 'Uy', 'Uz'], 'p'],
				dataName: run.results.map(r => r.name),
				order: [1, 1]
			}
		}); -%>
	}

	appendLog("End");
} catch(...) {
	appendError("An internal error occurs");
	exit(-1);
}