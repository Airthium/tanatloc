try {
<%# Headers -%>
<%- helpers.indent(include('/blobs/headers.edp.ejs'), 1) -%>

<%# Dimension -%>
<%- helpers.indent(include('/blobs/dimensioning.edp.ejs', {
	dimension
}), 1) -%>

<%# Mesh -%>
<%
const mesh = geometry.mesh
mesh.name = 'Mesh'
-%>
<%- helpers.indent(include('/blobs/mesh.edp.ejs', {
	dimension,
	mesh
}), 1) -%>

<%# Materials -%>
<%- helpers.indent(include('/blobs/materials.edp.ejs', {
	materials
}), 1) -%>

<%# Finite element space -%>
<%
const finiteElementSpace = parameters.finiteElementSpace.children[0]
finiteElementSpace.name = 'Uh'
-%>
<%- helpers.indent(include('/blobs/fespace.edp.ejs', {
	mesh,
	dimension,
	finiteElementSpace
}), 1) -%>

<%# Finite element function -%>
<%
let feFunction = ['Ux', 'Uy', 'Uz', 'p']

let unknownFunction = '[Ux, Uy, Uz, p]'
let testFunction = '[Uhx, Uhy, Uhz, ph]'
let freeFunction = '[mUx, mUy, mUz, mp]'

let U = '[Ux, Uy, Uz]'
let Uh = '[Uhx, Uhy, Uhz]'
let N = '[N.x, N.y, N.z]'

if (dimension === 2) {
	feFunction = ['Ux', 'Uy', 'p']

	unknownFunction = '[Ux, Uy, p]'
	testFunction = '[Uhx, Uhy, ph]'
	freeFunction = '[mUx, mUy, mp]'

	U = '[Ux, Uy]'
	Uh = '[Uhx, Uhy]'
	N = '[N.x, N.y]'
}
-%>
<%- helpers.indent(include('/blobs/fespaceFunction.edp.ejs', {
	finiteElementSpace,
	finiteElementFunction: feFunction
}), 1) -%>

<%# Macro -%>
<%- helpers.indent(include('/blobs/macro.edp.ejs', {
	dimension,
	type: ['vectorialGradient', 'vectorialDivergence']
}), 1) -%>

<%# Problem -%>
<% 
const symmetric = parameters.symmetric.children[0].value ?? parameters.symmetric.children[0].default
const wall = boundaryConditions.wall.values ?? []
const freeOutlet = boundaryConditions.freeOutlet.values ?? []
const dirichlet = boundaryConditions.dirichlet.values ?? []
const neumann = boundaryConditions.neumann.values ?? []
const rhs = parameters.rightHandSide.children
const rhsX = rhs[0].value ?? rhs[0].default
const rhsY = rhs[1].value ?? rhs[1].default
const rhsZ = rhs[2].value ?? rhs[2].default
-%>
	//Problem
	appendLog("Define the problem...");

	varf vStokes (<%= unknownFunction -%>, <%= testFunction -%>)
		= intN(Mesh)(
<% if (symmetric) { -%>
			(Mu/4.) * (
				  (grad(Ux) + grad(Ux)')' * grad(Uhx)
				+ (grad(Uy) + grad(Uy)')' * grad(Uhy)
<% if (dimension !== 2) { -%>
				+ (grad(Uz) + grad(Uz)')' * (grad(Uhz) + grad(Uhz)')
<% } -%>
			)
<% } else { -%>
			  Mu * (Grad(U) : Grad(Uh))
<% } -%>
			- p * Div(Uh)
			- Div(U) * ph
			- 1.e-9 * p * ph
		)
<% for (const d of dirichlet) { -%>
		+ on(<%= d.labels -%>
		<% if (d.values[0].checked) { -%>, Ux=0<% } -%>
		<% if (d.values[1].checked) { -%>, Uy=0<% } -%>
		<% if (dimension !== 2 && d.values[2].checked) { -%>, Uz=0<% } -%>
		)
<% } -%>
<% for (const w of wall) { -%>
		+ on(<%= w.labels -%>, Ux=0, Uy=0<% if (dimension !== 2) { -%> , Uz=0<% } -%>)
<% } -%>
		;

	varf vStokesRHS (<%= freeFunction -%>, <%= testFunction -%>)
		= intN(Mesh)(
<% if (dimension === 2) { -%>
			[<%- rhsX -%>, <%- rhsY -%>]' * <%= Uh %>
<% } else { -%>
			[<%- rhsX -%>, <%- rhsY -%>, <%- rhsZ -%>]' * <%= Uh %>
<% } -%>
		)
<% for (const n of neumann) { -%>
		- intN1(Mesh, <%= n.labels -%>)(
			(<%- n.values[0].value ?? n.values[0].default -%>) * <%= N -%>' * <%= testFunction -%>
		)
<% } -%>
<% for (const d of dirichlet) { -%>
		+ on(<%= d.labels -%>
		<% if (d.values[0].checked) { -%>, mUx=<%- d.values[0].value ?? d.values[0].default -%><% } -%>
		<% if (d.values[1].checked) { -%>, mUy=<%- d.values[1].value ?? d.values[1].default -%><% } -%>
		<% if (dimension !== 2 && d.values[2].checked) { -%>, mUz=<%- d.values[2].value ?? d.values[2].default -%><% } -%>)
<% } -%>
<% for (const w of wall) { -%>
		+ on(<%= w.labels -%>, mUx=0, mUy=0<% if (dimension !== 2) { -%> , mUz=0<% } -%>)
<% } -%>
		;

<%# Solver -%>
<% const solver = parameters.solver.children[0].value ?? parameters.solver.children[0].default -%>
<%- helpers.indent(include('/blobs/solver.edp.ejs', {
	solver
}), 1) -%>

<%# Solve -%>
	matrix Stokes = vStokes(<%= finiteElementSpace.name -%>, <%= finiteElementSpace.name -%>, solver=solver);
	real[int] StokesRHS = vStokesRHS(0, <%= finiteElementSpace.name -%>);

	// Solve
	Ux[] = Stokes^-1 * StokesRHS;

<%# Save -%>
	// Save data
	real netFlow = intN1(Mesh)(<%= U -%>' * <%= N -%>);
	real div = intN(Mesh)(Div(U)) / intN(Mesh)(1);
<%- helpers.indent(include('/blobs/data.edp.ejs', {
	title: '',
	path: run.dataPath,
	fileName: '"stokes"',
	dataNames: ['Net flow', 'Divergence'],
	x: '0',
	ys: ['netFlow', 'div']
}), 1) -%>

<%# Sensors -%>
<%- helpers.indent(include('/blobs/sensors.edp.ejs', {
	path: run.dataPath,
	x: 0,
	sensors: run.sensors
}), 1) -%>

<%- helpers.indent(include('/blobs/coupling.edp.ejs', {
	path: run.couplingPath,
	mesh: mesh.name,
	name: '"Result_"',
	data: dimension === 2 ? ['Ux', 'Uy'] : ['Ux', 'Uy', 'Uz']
}), 1) -%>

<%- helpers.indent(include('/blobs/save.edp.ejs', {
	solution: {
		path: run.resultPath,
		name: '"Result"',
		mesh: mesh.name,
		sol: [dimension === 2 ? ['Ux', 'Uy', '0'] : ['Ux', 'Uy', 'Uz'], 'p'],
		dataName: run.results.map(r => r.name),
		order: [1, 1]
	}
}), 1) -%>

	appendLog("End");
} catch(...) {
	appendError("An internal error occurs");
	exit(-1);
}