try {
    <%# Headers -%>
	<%- include('/blobs/headers.edp.ejs') -%>

	<%# Dimension -%>
	<%- include('/blobs/dimensioning.edp.ejs', {
		dimension
	}); -%>

	<%# Mesh -%>
	<%
	const mesh = geometry.mesh
	mesh.name = 'Mesh'
	-%>
	<%- include('/blobs/mesh.edp.ejs', {
		dimension,
		mesh
	}); -%>

    // Variables
    real t = 0.;
    real Time = <%= parameters.time.children[0].value || parameters.time.children[0].default -%>;
    real dt = <%= parameters.time.children[1].value || parameters.time.children[1].default -%>;

	<%# Material -%>
	<%- include('/blobs/materials.edp.ejs', {
		materials
	}) -%>

    <%# Finite element space -%>
	<%
	const finiteElementSpace = parameters.finiteElementSpace.children[0]
	finiteElementSpace.name = 'Uh'
	-%>
	<%- include('/blobs/fespace.edp.ejs', {
		mesh,
		finiteElementSpace
	}); -%>

    <%# Finite element function -%>
	<%- include('/blobs/fespaceFunction.edp.ejs', {
		finiteElementSpace,
		finiteElementFunction: ['T']
	}); -%>

    <%# Macro -%>
	<%- include('/blobs/macro.edp.ejs', {
		dimension,
		type: ['scalarGradient']
	}); -%>

    <%# Problem -%>
    <%
    const temperature = boundaryConditions.temperature.values ||[]
    -%> 
    // Problem
	appendLog("Define the problem...");

    varf vThermalDiffusion (T, Th)
        = intN(Mesh)(
              (Rho*Cp/dt) * T * Th
            + Lambda * grad(T)' * grad(Th)
        )
    <% for (const t of temperature) { -%>
            + on(<%= t.selected.map(s => s.label).filter(s => s).join() -%>,
            T=0
            )
    <% } -%>
        ;
    
    varf vThermalDiffusionRHS (Td, Th)
        = intN(Mesh)(
              (Rho*Cp/dt) * T * Th
        )
    <% for (const t of temperature) { -%>
        + on(<%= t.selected.map(s => s.label).filter(s => s).join() -%>,
        Td=<%= t.values[0].value ?? t.values[0].default -%>
        )
    <% } -%>
        ;
    
    <%# Solver -%>
	<% const solver = parameters.solver.children[0].value || parameters.solver.children[0].default -%>
	<%- include('/blobs/solver.edp.ejs', {
		solver
	}) -%>

    <%# Matrix -%>
    appendLog("Build matrix...");
    matrix ThermalDiffusion = vThermalDiffusion(<%= finiteElementSpace.name -%>, <%= finiteElementSpace.name -%>);

    <%# Time loop -%>
	// Time loop
	appendLog("Time loop...");

    int nbIter = Time / dt;
	for (int timeIter = 0; timeIter < nbIter; ++timeIter) {
		// Update
		t += dt;
		appendLog("Time: " + t);

        real[int] ThermalDiffusionRHS = vThermalDiffusionRHS(0, <%= finiteElementSpace.name -%>);

        // Solve
        T[] = ThermalDiffusion^-1 * ThermalDiffusionRHS;

        // Save results
		<%- include('/blobs/save.edp.ejs', {
			solution: {
				path: run.resultPath,
				name: '"Result_"+timeIter',
				mesh: mesh.name,
				sol: ['T'],
				dataName: run.results.map(r => r.name),
				order: [1]
			}
		}); -%>
    }

    appendLog("End");
} catch(...) {
    appendError("An internal error occurs");
    exit(-1);
}