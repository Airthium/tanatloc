try {
<%# Headers -%>
<%- helpers.indent(include('/blobs/headers.edp.ejs'), 1) -%>

<%# Dimension -%>
<%- helpers.indent(include('/blobs/dimensioning.edp.ejs', {
	dimension
}), 1) -%>

<%# Mesh -%>
<%
const mesh = geometry.mesh
mesh.name = 'Mesh'
-%>
<%- helpers.indent(include('/blobs/mesh.edp.ejs', {
	dimension,
	mesh
}), 1) -%>

    // Variables
    real t = 0.;
    real Time = <%= parameters.time.children[0].value ?? parameters.time.children[0].default -%>;
    real dt = <%= parameters.time.children[1].value ?? parameters.time.children[1].default -%>;

<%# Material -%>
<%- helpers.indent(include('/blobs/materials.edp.ejs', {
	materials
}), 1) -%>

<%# Finite element space -%>
<%
const finiteElementSpace = parameters.finiteElementSpace.children[0]
finiteElementSpace.name = 'Uh'
-%>
<%- helpers.indent(include('/blobs/fespace.edp.ejs', {
	mesh,
    dimension,
	finiteElementSpace
}), 1) -%>

<%# Finite element function -%>
<%- helpers.indent(include('/blobs/fespaceFunction.edp.ejs', {
	finiteElementSpace,
	finiteElementFunction: ['T']
}), 1) -%>

<%# Macro -%>
<%- helpers.indent(include('/blobs/macro.edp.ejs', {
	dimension,
	type: ['scalarGradient']
}), 1) -%>

<%# Problem -%>
<%
const temperature = boundaryConditions.temperature.values ?? []
-%>
    // Problem
	appendLog("Define the problem...");

    varf vThermalDiffusion (T, Th)
        = intN(Mesh)(
              (Rho*Cp/dt) * T * Th
            + Lambda * grad(T)' * grad(Th)
        )
<% for (const t of temperature) { -%>
            + on(<%= t.selected.map(s => s.label).filter(s => s).join(', ') -%>,
            T=0
            )
<% } -%>
        ;
    
    varf vThermalDiffusionRHS (Td, Th)
        = intN(Mesh)(
              (Rho*Cp/dt) * T * Th
        )
<% for (const t of temperature) { -%>
        + on(<%= t.selected.map(s => s.label).filter(s => s).join(', ') -%>,
        Td=<%= t.values[0].value ?? t.values[0].default -%>
        )
<% } -%>
        ;
    
<%# Solver -%>
<% const solver = parameters.solver.children[0].value ?? parameters.solver.children[0].default -%>
<%- helpers.indent(include('/blobs/solver.edp.ejs', {
	solver
}), 1) -%>

<%# Matrix -%>
    appendLog("Build matrix...");
    matrix ThermalDiffusion = vThermalDiffusion(<%= finiteElementSpace.name -%>, <%= finiteElementSpace.name -%>);

<%# Time loop -%>
	// Time loop
	appendLog("Time loop...");

    int nbIter = Time / dt;
	for (int timeIter = 0; timeIter < nbIter; ++timeIter) {
		// Update
        int percent = 100 * t / Time;
		appendLog("[" + percent + "%]");
		t += dt;
		appendLog("Time: " + t);

        real[int] ThermalDiffusionRHS = vThermalDiffusionRHS(0, <%= finiteElementSpace.name -%>);

        // Solve
        T[] = ThermalDiffusion^-1 * ThermalDiffusionRHS;

<%# Sensors -%>
<%- helpers.indent(include('/blobs/sensors.edp.ejs', {
	path: run.dataPath,
	x: 'timeIter',
	sensors: run.sensors
}), 2) -%>
        
<%- helpers.indent(include('/blobs/save.edp.ejs', {
	solution: {
		path: run.resultPath,
		name: '"Result_"+timeIter',
		mesh: mesh.name,
		sol: ['T'],
		dataName: run.results.map(r => r.name),
		order: [1]
	}
}), 2) -%>
    }
    appendLog("[100%]");

    appendLog("End");
} catch(...) {
    appendError("An internal error occurs");
    exit(-1);
}